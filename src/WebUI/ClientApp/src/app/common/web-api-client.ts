/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.11.3.0 (NJsonSchema v10.4.4.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import {
  HttpClient,
  HttpHeaders,
  HttpResponse,
  HttpResponseBase,
} from "@angular/common/http";
import { Inject, Injectable, InjectionToken, Optional } from "@angular/core";
import {
  Observable,
  of as _observableOf,
  throwError as _observableThrow,
} from "rxjs";
import {
  catchError as _observableCatch,
  mergeMap as _observableMergeMap,
} from "rxjs/operators";
import { APIResponse } from "../models/APIResponse";

export const API_BASE_URL = new InjectionToken<string>("API_BASE_URL");

export interface IBookingClient {
  getList(cmd: GetAvailableBookingCommand): Observable<SimpleBookingDto[]>;
  create(cmd: CreateSimpleBookingCommand): Observable<APIResponse>;
  getAllViewBookRoom(
    cmd: GetAvailableBookingCommand
  ): Observable<SimpleBookingDto[]>;
  getMyRawBooking(bookingId: number | undefined): Observable<Booking[]>;
  cancelBooking(cmd: CancelCommand): Observable<boolean>;
  updateSimpleBooking(cmd: UpdateSimpleBookingCommand): Observable<APIResponse>;
  getMarkedAsClosed(cmd: GetMarkedAsClosedCommand): Observable<Booking[]>;
}

@Injectable({
  providedIn: "root",
})
export class BookingClient implements IBookingClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  getList(cmd: GetAvailableBookingCommand): Observable<SimpleBookingDto[]> {
    let url_ = this.baseUrl + "/api/Booking/GetList";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(cmd);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        Accept: "application/json",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetList(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetList(<any>response_);
            } catch (e) {
              return <Observable<SimpleBookingDto[]>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<SimpleBookingDto[]>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetList(
    response: HttpResponseBase
  ): Observable<SimpleBookingDto[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(SimpleBookingDto.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    // return _observableOf<SimpleBookingDto[]>(<any>null);
    return _observableOf();
  }

  PostCall(url: string, data: any = {}) {
    return this.http.post(this.baseUrl + url, data);
  }

  PostCallWithData<T>(url: string, data: any = {}): Observable<T> {
    return this.http.post<T>(this.baseUrl + url, data);
  }

  GetCallWithData<T>(url: string, data: any = {}): Observable<T> {
    return this.http.get<T>(this.baseUrl + url, { params: data });
  }

  getFirstSlot(cmd: GetAvailableBookingCommand): Observable<SimpleBookingDto> {
    let url_ = this.baseUrl + "/api/Booking/GetFirstSlot";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(cmd);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        Accept: "application/json",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processSimpleBooking(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processSimpleBooking(<any>response_);
            } catch (e) {
              return <Observable<SimpleBookingDto>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<SimpleBookingDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processSimpleBooking(
    response: HttpResponseBase
  ): Observable<SimpleBookingDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (resultData200) {
            result200 = SimpleBookingDto.fromJS(resultData200);
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<SimpleBookingDto>(<any>null);
  }

  create(cmd: CreateSimpleBookingCommand): Observable<APIResponse> {
    let url_ = this.baseUrl + "/api/Booking/Create";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(cmd);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        Accept: "application/json",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreate(<any>response_);
            } catch (e) {
              return <Observable<APIResponse>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<APIResponse>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCreate(response: HttpResponseBase): Observable<APIResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<APIResponse>(<any>null);
  }

  getAllViewBookRoom(
    cmd: GetAvailableBookingCommand
  ): Observable<SimpleBookingDto[]> {
    let url_ = this.baseUrl + "/api/Booking/GetAllViewBookRoom";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(cmd);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        Accept: "application/json",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllViewBookRoom(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllViewBookRoom(<any>response_);
            } catch (e) {
              return <Observable<SimpleBookingDto[]>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<SimpleBookingDto[]>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetAllViewBookRoom(
    response: HttpResponseBase
  ): Observable<SimpleBookingDto[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(SimpleBookingDto.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    // return _observableOf<SimpleBookingDto[]>(<any>null);
    return _observableOf();
  }

  getMyRawBooking(bookingId: number | undefined): Observable<Booking[]> {
    let url_ = this.baseUrl + "/api/Booking/GetMyRawBooking?";
    if (bookingId === null)
      throw new Error("The parameter 'bookingId' cannot be null.");
    else if (bookingId !== undefined)
      url_ += "bookingId=" + encodeURIComponent("" + bookingId) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetMyRawBooking(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetMyRawBooking(<any>response_);
            } catch (e) {
              return <Observable<Booking[]>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<Booking[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetMyRawBooking(
    response: HttpResponseBase
  ): Observable<Booking[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(Booking.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    // return _observableOf<Booking[]>(<any>null);
    return _observableOf();
  }

  getClosedBooking(bookingId: number | undefined): Observable<Booking[]> {
    let url_ = this.baseUrl + "/api/Booking/GetClosedBooking?";
    if (bookingId === null)
      throw new Error("The parameter 'bookingId' cannot be null.");
    else if (bookingId !== undefined)
      url_ += "bookingId=" + encodeURIComponent("" + bookingId) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetClosedBooking(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetClosedBooking(<any>response_);
            } catch (e) {
              return <Observable<Booking[]>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<Booking[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetClosedBooking(
    response: HttpResponseBase
  ): Observable<Booking[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(Booking.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    // return _observableOf<Booking[]>(<any>null);
    return _observableOf();
  }

  cancelBooking(cmd: CancelCommand): Observable<boolean> {
    let url_ = this.baseUrl + "/api/Booking/CancelBooking";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(cmd);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        Accept: "application/json",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCancelBooking(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCancelBooking(<any>response_);
            } catch (e) {
              return <Observable<boolean>>(<any>_observableThrow(e));
            }
          } else return <Observable<boolean>>(<any>_observableThrow(response_));
        })
      );
  }

  cancelBookings(lstIds: Array<number>): Observable<boolean> {
    const content_ = JSON.stringify(lstIds);
    let url_ = this.baseUrl + "/api/Booking/CancelBookings";

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        Accept: "application/json",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCancelBooking(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCancelBooking(<any>response_);
            } catch (e) {
              return <Observable<boolean>>(<any>_observableThrow(e));
            }
          } else return <Observable<boolean>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCancelBooking(
    response: HttpResponseBase
  ): Observable<boolean> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<boolean>(<any>null);
  }

  updateSimpleBooking(
    cmd: UpdateSimpleBookingCommand
  ): Observable<APIResponse> {
    let url_ = this.baseUrl + "/api/Booking/UpdateSimpleBooking";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(cmd);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        Accept: "application/json",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdateSimpleBooking(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdateSimpleBooking(<any>response_);
            } catch (e) {
              return <Observable<APIResponse>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<APIResponse>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdateSimpleBooking(
    response: HttpResponseBase
  ): Observable<APIResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<APIResponse>(<any>null);
  }

  getMarkedAsClosed(cmd: GetMarkedAsClosedCommand): Observable<Booking[]> {
    let url_ = this.baseUrl + "/api/Booking/GetMarkedAsClosed";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(cmd);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        Accept: "application/json",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetMarkedAsClosed(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetMarkedAsClosed(<any>response_);
            } catch (e) {
              return <Observable<Booking[]>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<Booking[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetMarkedAsClosed(
    response: HttpResponseBase
  ): Observable<Booking[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(Booking.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    // return _observableOf<Booking[]>(<any>null);
    return _observableOf();
  }
}

export interface IEquipmentClient {
  getNameList(): Observable<EquipmentNameDtos[]>;
  addEquipment(cmd: CreateEquipmentCommand): Observable<number>;
  removeEquipment(cmd: DeleteEquipmentCommand): Observable<number>;
  updateEquipment(cmd: UpdateEquipmentCommand): Observable<number>;
}

@Injectable({
  providedIn: "root",
})
export class EquipmentClient implements IEquipmentClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  getNameList(): Observable<EquipmentNameDtos[]> {
    let url_ = this.baseUrl + "/api/Equipment/GetNameList";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetNameList(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetNameList(<any>response_);
            } catch (e) {
              return <Observable<EquipmentNameDtos[]>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<EquipmentNameDtos[]>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetNameList(
    response: HttpResponseBase
  ): Observable<EquipmentNameDtos[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(EquipmentNameDtos.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    // return _observableOf<EquipmentNameDtos[]>(<any>null);
    return _observableOf();
  }

  addEquipment(cmd: CreateEquipmentCommand): Observable<number> {
    let url_ = this.baseUrl + "/api/Equipment/AddEquipment";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(cmd);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        Accept: "application/json",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAddEquipment(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAddEquipment(<any>response_);
            } catch (e) {
              return <Observable<number>>(<any>_observableThrow(e));
            }
          } else return <Observable<number>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAddEquipment(
    response: HttpResponseBase
  ): Observable<number> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<number>(<any>null);
  }

  removeEquipment(cmd: DeleteEquipmentCommand): Observable<number> {
    let url_ = this.baseUrl + "/api/Equipment/RemoveEquipment";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(cmd);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        Accept: "application/json",
      }),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processRemoveEquipment(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processRemoveEquipment(<any>response_);
            } catch (e) {
              return <Observable<number>>(<any>_observableThrow(e));
            }
          } else return <Observable<number>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processRemoveEquipment(
    response: HttpResponseBase
  ): Observable<number> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<number>(<any>null);
  }

  updateEquipment(cmd: UpdateEquipmentCommand): Observable<number> {
    let url_ = this.baseUrl + "/api/Equipment/UpdateEquipment";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(cmd);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        Accept: "application/json",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdateEquipment(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdateEquipment(<any>response_);
            } catch (e) {
              return <Observable<number>>(<any>_observableThrow(e));
            }
          } else return <Observable<number>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdateEquipment(
    response: HttpResponseBase
  ): Observable<number> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<number>(<any>null);
  }
}

export interface IFireTestClient {
  welcome3(
    userName: string | null | undefined,
    jobId: number | undefined
  ): Observable<FileResponse>;
}

@Injectable({
  providedIn: "root",
})
export class FireTestClient implements IFireTestClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  welcome3(
    userName: string | null | undefined,
    jobId: number | undefined
  ): Observable<FileResponse> {
    let url_ = this.baseUrl + "/api/FireTest/Welcome3?";
    if (userName !== undefined && userName !== null)
      url_ += "userName=" + encodeURIComponent("" + userName) + "&";
    if (jobId === null)
      throw new Error("The parameter 'jobId' cannot be null.");
    else if (jobId !== undefined)
      url_ += "jobId=" + encodeURIComponent("" + jobId) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "application/octet-stream",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processWelcome3(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processWelcome3(<any>response_);
            } catch (e) {
              return <Observable<FileResponse>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<FileResponse>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processWelcome3(
    response: HttpResponseBase
  ): Observable<FileResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get("content-disposition")
        : undefined;
      const fileNameMatch = contentDisposition
        ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
        : undefined;
      const fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[1]
          : undefined;
      return _observableOf({
        fileName: fileName,
        data: <any>responseBlob,
        status: status,
        headers: _headers,
      });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<FileResponse>(<any>null);
  }
}

export interface IRoomClient {
  getFullList(): Observable<RoomNameListDto[]>;
  getOne(id: number | undefined): Observable<CreateUpdateRoomDto>;
  createRoom(cmd: CreateRoomCommand): Observable<number>;
  deleteRoom(id: number | undefined): Observable<Unit>;
  updateRoom(query: UpdateRoomCommand): Observable<number>;
  createUpdateRoom(query: CreateUpdateRoomDto): Observable<number>;
  getMyList(): Observable<RoomNameListDto[]>;
  createRoomSet(cmd: CreateRoomSetCommand): Observable<number>;
  updateRoomSet(cmd: UpdateRoomSetCommand): Observable<number>;
  deleteRoomSet(cmd: DeleteRoomSetCommand): Observable<boolean>;
  getAllRoomSet(cmd: GetAllRoomSets): Observable<RoomSet[]>;
  getOneRoomSet(setId: number | undefined): Observable<RoomSetDto>;
  getRoomSetSimple(): Observable<RoomSetSimpleDto[]>;
  getRoomExtraFields(): Observable<RoomExtraInfoTemplate[]>;
  updateRoomExtraFields(cmd: UpdateRoomExtraFieldsCommand): Observable<boolean>;
}

@Injectable({
  providedIn: "root",
})
export class RoomClient implements IRoomClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  getFullList(): Observable<RoomNameListDto[]> {
    let url_ = this.baseUrl + "/api/Room/GetFullList";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetFullList(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetFullList(<any>response_);
            } catch (e) {
              return <Observable<RoomNameListDto[]>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<RoomNameListDto[]>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  getRoomList(): Observable<RoomNameListDto[]> {
    let url_ = this.baseUrl + "/api/Room/GetFullList";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        Accept: "application/json",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetFullList(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetFullList(<any>response_);
            } catch (e) {
              return <Observable<RoomNameListDto[]>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<RoomNameListDto[]>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetFullList(
    response: HttpResponseBase
  ): Observable<RoomNameListDto[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(RoomNameListDto.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    // return _observableOf<RoomNameListDto[]>(<any>null);
    return _observableOf();
  }

  getOne(id: number | undefined): Observable<CreateUpdateRoomDto> {
    let url_ = this.baseUrl + "/api/Room/GetOne?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetOne(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetOne(<any>response_);
            } catch (e) {
              return <Observable<CreateUpdateRoomDto>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<CreateUpdateRoomDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetOne(
    response: HttpResponseBase
  ): Observable<CreateUpdateRoomDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = CreateUpdateRoomDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<CreateUpdateRoomDto>(<any>null);
  }

  createRoom(cmd: CreateRoomCommand): Observable<number> {
    let url_ = this.baseUrl + "/api/Room/CreateRoom";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(cmd);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        Accept: "application/json",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreateRoom(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreateRoom(<any>response_);
            } catch (e) {
              return <Observable<number>>(<any>_observableThrow(e));
            }
          } else return <Observable<number>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCreateRoom(response: HttpResponseBase): Observable<number> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<number>(<any>null);
  }

  deleteRoom(id: number | undefined): Observable<Unit> {
    let url_ = this.baseUrl + "/api/Room/DeleteRoom?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDeleteRoom(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDeleteRoom(<any>response_);
            } catch (e) {
              return <Observable<Unit>>(<any>_observableThrow(e));
            }
          } else return <Observable<Unit>>(<any>_observableThrow(response_));
        })
      );
  }

  deleteRooms(ids: Array<number>) {
    return this.http.post(this.baseUrl + "/api/Room/DeleteRooms", { ids: ids });
  }

  bulkDeleteRooms(lstIds: Array<number>) {
    return this.http.post(this.baseUrl + "/api/Room/DeleteRooms", lstIds);
  }

  PostCall(url: string, data: any = {}) {
    return this.http.post(this.baseUrl + url, data);
  }

  protected processDeleteRoom(response: HttpResponseBase): Observable<Unit> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = Unit.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<Unit>(<any>null);
  }

  updateRoom(query: UpdateRoomCommand): Observable<number> {
    let url_ = this.baseUrl + "/api/Room/UpdateRoom";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(query);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        Accept: "application/json",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdateRoom(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdateRoom(<any>response_);
            } catch (e) {
              return <Observable<number>>(<any>_observableThrow(e));
            }
          } else return <Observable<number>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdateRoom(response: HttpResponseBase): Observable<number> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<number>(<any>null);
  }

  createUpdateRoom(query: CreateUpdateRoomDto): Observable<number> {
    let url_ = this.baseUrl + "/api/Room/CreateUpdateRoom";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(query);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        Accept: "application/json",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreateUpdateRoom(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreateUpdateRoom(<any>response_);
            } catch (e) {
              return <Observable<number>>(<any>_observableThrow(e));
            }
          } else return <Observable<number>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCreateUpdateRoom(
    response: HttpResponseBase
  ): Observable<number> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<number>(<any>null);
  }

  getMyList(): Observable<RoomNameListDto[]> {
    let url_ = this.baseUrl + "/api/Room/GetMyList";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetMyList(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetMyList(<any>response_);
            } catch (e) {
              return <Observable<RoomNameListDto[]>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<RoomNameListDto[]>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetMyList(
    response: HttpResponseBase
  ): Observable<RoomNameListDto[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(RoomNameListDto.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    // return _observableOf<RoomNameListDto[]>(<any>null);
    return _observableOf();
  }

  createRoomSet(cmd: CreateRoomSetCommand): Observable<number> {
    let url_ = this.baseUrl + "/api/Room/CreateRoomSet";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(cmd);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        Accept: "application/json",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreateRoomSet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreateRoomSet(<any>response_);
            } catch (e) {
              return <Observable<number>>(<any>_observableThrow(e));
            }
          } else return <Observable<number>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCreateRoomSet(
    response: HttpResponseBase
  ): Observable<number> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<number>(<any>null);
  }

  updateRoomSet(cmd: UpdateRoomSetCommand): Observable<number> {
    let url_ = this.baseUrl + "/api/Room/UpdateRoomSet";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(cmd);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        Accept: "application/json",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdateRoomSet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdateRoomSet(<any>response_);
            } catch (e) {
              return <Observable<number>>(<any>_observableThrow(e));
            }
          } else return <Observable<number>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdateRoomSet(
    response: HttpResponseBase
  ): Observable<number> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<number>(<any>null);
  }

  deleteRoomSet(cmd: DeleteRoomSetCommand): Observable<boolean> {
    let url_ = this.baseUrl + "/api/Room/DeleteRoomSet";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(cmd);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        Accept: "application/json",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDeleteRoomSet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDeleteRoomSet(<any>response_);
            } catch (e) {
              return <Observable<boolean>>(<any>_observableThrow(e));
            }
          } else return <Observable<boolean>>(<any>_observableThrow(response_));
        })
      );
  }

  deleteRoomSets(lstIds: Array<number>): Observable<boolean> {
    const content_ = JSON.stringify(lstIds);
    let url_ = this.baseUrl + "/api/Room/DeleteRoomSets";

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        Accept: "application/json",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDeleteRoomSet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDeleteRoomSet(<any>response_);
            } catch (e) {
              return <Observable<boolean>>(<any>_observableThrow(e));
            }
          } else return <Observable<boolean>>(<any>_observableThrow(response_));
        })
      );
  }

  deleteBooking(bookingId: number): Observable<boolean> {
    let url_ = this.baseUrl + "/api/Booking/DeleteBooking?";
    if (bookingId === null)
      throw new Error("The parameter 'bookingId' cannot be null.");
    else if (bookingId !== undefined)
      url_ += "bookingId=" + encodeURIComponent("" + bookingId) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDeleteRoomSet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDeleteRoomSet(<any>response_);
            } catch (e) {
              return <Observable<boolean>>(<any>_observableThrow(e));
            }
          } else return <Observable<boolean>>(<any>_observableThrow(response_));
        })
      );
  }

  deleteBookings(lstIds: Array<number>): Observable<boolean> {
    const content_ = JSON.stringify(lstIds);
    let url_ = this.baseUrl + "/api/Booking/DeleteBookings";

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        Accept: "application/json",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDeleteRoomSet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDeleteRoomSet(<any>response_);
            } catch (e) {
              return <Observable<boolean>>(<any>_observableThrow(e));
            }
          } else return <Observable<boolean>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDeleteRoomSet(
    response: HttpResponseBase
  ): Observable<boolean> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<boolean>(<any>null);
  }

  getAllRoomSet(cmd: GetAllRoomSets): Observable<RoomSet[]> {
    let url_ = this.baseUrl + "/api/Room/GetAllRoomSet";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(cmd);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        Accept: "application/json",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllRoomSet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllRoomSet(<any>response_);
            } catch (e) {
              return <Observable<RoomSet[]>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<RoomSet[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAllRoomSet(
    response: HttpResponseBase
  ): Observable<RoomSet[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(RoomSet.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    // return _observableOf<RoomSet[]>(<any>null);
    return _observableOf();
  }

  getOneRoomSet(setId: number | undefined): Observable<RoomSetDto> {
    let url_ = this.baseUrl + "/api/Room/GetOneRoomSet?";
    if (setId === null)
      throw new Error("The parameter 'setId' cannot be null.");
    else if (setId !== undefined)
      url_ += "setId=" + encodeURIComponent("" + setId) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetOneRoomSet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetOneRoomSet(<any>response_);
            } catch (e) {
              return <Observable<RoomSetDto>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<RoomSetDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetOneRoomSet(
    response: HttpResponseBase
  ): Observable<RoomSetDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = RoomSetDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<RoomSetDto>(<any>null);
  }

  getRoomSetSimple(): Observable<RoomSetSimpleDto[]> {
    let url_ = this.baseUrl + "/api/Room/GetRoomSetSimple";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetRoomSetSimple(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetRoomSetSimple(<any>response_);
            } catch (e) {
              return <Observable<RoomSetSimpleDto[]>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<RoomSetSimpleDto[]>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetRoomSetSimple(
    response: HttpResponseBase
  ): Observable<RoomSetSimpleDto[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(RoomSetSimpleDto.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    // return _observableOf<RoomSetSimpleDto[]>(<any>null);
    return _observableOf();
  }

  getRoomExtraFields(): Observable<RoomExtraInfoTemplate[]> {
    let url_ = this.baseUrl + "/api/Room/GetRoomExtraFields";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetRoomExtraFields(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetRoomExtraFields(<any>response_);
            } catch (e) {
              return <Observable<RoomExtraInfoTemplate[]>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<RoomExtraInfoTemplate[]>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetRoomExtraFields(
    response: HttpResponseBase
  ): Observable<RoomExtraInfoTemplate[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(RoomExtraInfoTemplate.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    // return _observableOf<RoomExtraInfoTemplate[]>(<any>null);
    return _observableOf();
  }

  updateRoomExtraFields(
    cmd: UpdateRoomExtraFieldsCommand
  ): Observable<boolean> {
    let url_ = this.baseUrl + "/api/Room/UpdateRoomExtraFields";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(cmd);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        Accept: "application/json",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdateRoomExtraFields(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdateRoomExtraFields(<any>response_);
            } catch (e) {
              return <Observable<boolean>>(<any>_observableThrow(e));
            }
          } else return <Observable<boolean>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdateRoomExtraFields(
    response: HttpResponseBase
  ): Observable<boolean> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<boolean>(<any>null);
  }
}

export interface ITestBookingsClient {
  simpleDummy(): Observable<BookingEvent[]>;
}

@Injectable({
  providedIn: "root",
})
export class TestBookingsClient implements ITestBookingsClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  simpleDummy(): Observable<BookingEvent[]> {
    let url_ = this.baseUrl + "/api/TestBookings/SimpleDummy";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processSimpleDummy(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processSimpleDummy(<any>response_);
            } catch (e) {
              return <Observable<BookingEvent[]>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<BookingEvent[]>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processSimpleDummy(
    response: HttpResponseBase
  ): Observable<BookingEvent[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(BookingEvent.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    // return _observableOf<BookingEvent[]>(<any>null);
    return _observableOf();
  }
}

export interface ITestEmailClient {
  testing(command: SendTestMailCommand): Observable<SendResponse>;
  fireSchedule(cmd: SendTestMailCommand): Observable<FileResponse>;
  firefire(cmd: SendTestMailCommand): Observable<FileResponse>;
  getSimpleServiceDto(): Observable<SimpleServiceDto>;
  updateSimpleServiceDto(name: string | null | undefined): Observable<string>;
  simpleAddOne(): Observable<boolean>;
  updateEmailSettings(cmd: UpdateEmailSettingsCommand): Observable<boolean>;
  getRawSmtpInfo(): Observable<SmtpClientOptions>;
  getFireStatus(jobId: string | null | undefined): Observable<string>;
}

@Injectable({
  providedIn: "root",
})
export class TestEmailClient implements ITestEmailClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  sendtestmail(data: any = {}) {
    let url_ = this.baseUrl + "/api/TestEmail/sendtestmail";
    return this.http.post(this.baseUrl + url_, data);
  }

  testing(command: SendTestMailCommand): Observable<SendResponse> {
    let url_ = this.baseUrl + "/api/TestEmail/testing";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(command);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        Accept: "application/json",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processTesting(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processTesting(<any>response_);
            } catch (e) {
              return <Observable<SendResponse>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<SendResponse>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processTesting(
    response: HttpResponseBase
  ): Observable<SendResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = SendResponse.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<SendResponse>(<any>null);
  }

  fireSchedule(cmd: SendTestMailCommand): Observable<FileResponse> {
    let url_ = this.baseUrl + "/api/TestEmail/fireSchedule";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(cmd);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        Accept: "application/octet-stream",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processFireSchedule(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processFireSchedule(<any>response_);
            } catch (e) {
              return <Observable<FileResponse>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<FileResponse>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processFireSchedule(
    response: HttpResponseBase
  ): Observable<FileResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get("content-disposition")
        : undefined;
      const fileNameMatch = contentDisposition
        ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
        : undefined;
      const fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[1]
          : undefined;
      return _observableOf({
        fileName: fileName,
        data: <any>responseBlob,
        status: status,
        headers: _headers,
      });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<FileResponse>(<any>null);
  }

  firefire(cmd: SendTestMailCommand): Observable<FileResponse> {
    let url_ = this.baseUrl + "/api/TestEmail/firefire";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(cmd);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        Accept: "application/octet-stream",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processFirefire(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processFirefire(<any>response_);
            } catch (e) {
              return <Observable<FileResponse>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<FileResponse>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processFirefire(
    response: HttpResponseBase
  ): Observable<FileResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get("content-disposition")
        : undefined;
      const fileNameMatch = contentDisposition
        ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
        : undefined;
      const fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[1]
          : undefined;
      return _observableOf({
        fileName: fileName,
        data: <any>responseBlob,
        status: status,
        headers: _headers,
      });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<FileResponse>(<any>null);
  }

  getSimpleServiceDto(): Observable<SimpleServiceDto> {
    let url_ = this.baseUrl + "/api/TestEmail/GetSimpleServiceDto";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetSimpleServiceDto(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetSimpleServiceDto(<any>response_);
            } catch (e) {
              return <Observable<SimpleServiceDto>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<SimpleServiceDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetSimpleServiceDto(
    response: HttpResponseBase
  ): Observable<SimpleServiceDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = SimpleServiceDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<SimpleServiceDto>(<any>null);
  }

  updateSimpleServiceDto(name: string | null | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/TestEmail/UpdateSimpleServiceDto?";
    if (name !== undefined && name !== null)
      url_ += "name=" + encodeURIComponent("" + name) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdateSimpleServiceDto(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdateSimpleServiceDto(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdateSimpleServiceDto(
    response: HttpResponseBase
  ): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  simpleAddOne(): Observable<boolean> {
    let url_ = this.baseUrl + "/api/TestEmail/SimpleAddOne";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processSimpleAddOne(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processSimpleAddOne(<any>response_);
            } catch (e) {
              return <Observable<boolean>>(<any>_observableThrow(e));
            }
          } else return <Observable<boolean>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processSimpleAddOne(
    response: HttpResponseBase
  ): Observable<boolean> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<boolean>(<any>null);
  }

  updateEmailSettings(cmd: UpdateEmailSettingsCommand): Observable<boolean> {
    let url_ = this.baseUrl + "/api/TestEmail/UpdateEmailSettings";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(cmd);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        Accept: "application/json",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdateEmailSettings(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdateEmailSettings(<any>response_);
            } catch (e) {
              return <Observable<boolean>>(<any>_observableThrow(e));
            }
          } else return <Observable<boolean>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdateEmailSettings(
    response: HttpResponseBase
  ): Observable<boolean> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<boolean>(<any>null);
  }

  getRawSmtpInfo(): Observable<SmtpClientOptions> {
    let url_ = this.baseUrl + "/api/TestEmail/GetRawSmtpInfo";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetRawSmtpInfo(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetRawSmtpInfo(<any>response_);
            } catch (e) {
              return <Observable<SmtpClientOptions>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<SmtpClientOptions>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetRawSmtpInfo(
    response: HttpResponseBase
  ): Observable<SmtpClientOptions> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = SmtpClientOptions.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<SmtpClientOptions>(<any>null);
  }

  getFireStatus(jobId: string | null | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/TestEmail/GetFireStatus?";
    if (jobId !== undefined && jobId !== null)
      url_ += "jobId=" + encodeURIComponent("" + jobId) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetFireStatus(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetFireStatus(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetFireStatus(
    response: HttpResponseBase
  ): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }
}

export interface ITodoItemsClient {
  getTodoItemsWithPagination(
    listId: number | undefined,
    pageNumber: number | undefined,
    pageSize: number | undefined
  ): Observable<PaginatedListOfTodoItemDto>;
  create(command: CreateTodoItemCommand): Observable<number>;
  update(id: number, command: UpdateTodoItemCommand): Observable<FileResponse>;
  updateItemDetails(
    id: number | undefined,
    command: UpdateTodoItemDetailCommand
  ): Observable<FileResponse>;
  delete(id: number): Observable<FileResponse>;
}

@Injectable({
  providedIn: "root",
})
export class TodoItemsClient implements ITodoItemsClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  getTodoItemsWithPagination(
    listId: number | undefined,
    pageNumber: number | undefined,
    pageSize: number | undefined
  ): Observable<PaginatedListOfTodoItemDto> {
    let url_ = this.baseUrl + "/api/TodoItems/GetTodoItemsWithPagination?";
    if (listId === null)
      throw new Error("The parameter 'listId' cannot be null.");
    else if (listId !== undefined)
      url_ += "ListId=" + encodeURIComponent("" + listId) + "&";
    if (pageNumber === null)
      throw new Error("The parameter 'pageNumber' cannot be null.");
    else if (pageNumber !== undefined)
      url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
    if (pageSize === null)
      throw new Error("The parameter 'pageSize' cannot be null.");
    else if (pageSize !== undefined)
      url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetTodoItemsWithPagination(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetTodoItemsWithPagination(<any>response_);
            } catch (e) {
              return <Observable<PaginatedListOfTodoItemDto>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<PaginatedListOfTodoItemDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetTodoItemsWithPagination(
    response: HttpResponseBase
  ): Observable<PaginatedListOfTodoItemDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PaginatedListOfTodoItemDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<PaginatedListOfTodoItemDto>(<any>null);
  }

  create(command: CreateTodoItemCommand): Observable<number> {
    let url_ = this.baseUrl + "/api/TodoItems/Create";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(command);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        Accept: "application/json",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreate(<any>response_);
            } catch (e) {
              return <Observable<number>>(<any>_observableThrow(e));
            }
          } else return <Observable<number>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCreate(response: HttpResponseBase): Observable<number> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<number>(<any>null);
  }

  update(id: number, command: UpdateTodoItemCommand): Observable<FileResponse> {
    let url_ = this.baseUrl + "/api/TodoItems/Update/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(command);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        Accept: "application/octet-stream",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<FileResponse>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<FileResponse>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdate(
    response: HttpResponseBase
  ): Observable<FileResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get("content-disposition")
        : undefined;
      const fileNameMatch = contentDisposition
        ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
        : undefined;
      const fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[1]
          : undefined;
      return _observableOf({
        fileName: fileName,
        data: <any>responseBlob,
        status: status,
        headers: _headers,
      });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<FileResponse>(<any>null);
  }

  updateItemDetails(
    id: number | undefined,
    command: UpdateTodoItemDetailCommand
  ): Observable<FileResponse> {
    let url_ =
      this.baseUrl + "/api/TodoItems/UpdateItemDetails/UpdateItemDetails?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(command);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        Accept: "application/octet-stream",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdateItemDetails(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdateItemDetails(<any>response_);
            } catch (e) {
              return <Observable<FileResponse>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<FileResponse>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdateItemDetails(
    response: HttpResponseBase
  ): Observable<FileResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get("content-disposition")
        : undefined;
      const fileNameMatch = contentDisposition
        ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
        : undefined;
      const fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[1]
          : undefined;
      return _observableOf({
        fileName: fileName,
        data: <any>responseBlob,
        status: status,
        headers: _headers,
      });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<FileResponse>(<any>null);
  }

  delete(id: number): Observable<FileResponse> {
    let url_ = this.baseUrl + "/api/TodoItems/Delete/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "application/octet-stream",
      }),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<FileResponse>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<FileResponse>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(
    response: HttpResponseBase
  ): Observable<FileResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get("content-disposition")
        : undefined;
      const fileNameMatch = contentDisposition
        ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
        : undefined;
      const fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[1]
          : undefined;
      return _observableOf({
        fileName: fileName,
        data: <any>responseBlob,
        status: status,
        headers: _headers,
      });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<FileResponse>(<any>null);
  }
}

export interface ITodoListsClient {
  get(): Observable<TodosVm>;
  get2(id: number): Observable<FileResponse>;
  create(command: CreateTodoListCommand): Observable<number>;
  update(id: number, command: UpdateTodoListCommand): Observable<FileResponse>;
  delete(id: number): Observable<FileResponse>;
}

@Injectable({
  providedIn: "root",
})
export class TodoListsClient implements ITodoListsClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  get(): Observable<TodosVm> {
    let url_ = this.baseUrl + "/api/TodoLists/Get";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(<any>response_);
            } catch (e) {
              return <Observable<TodosVm>>(<any>_observableThrow(e));
            }
          } else return <Observable<TodosVm>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGet(response: HttpResponseBase): Observable<TodosVm> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = TodosVm.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<TodosVm>(<any>null);
  }

  get2(id: number): Observable<FileResponse> {
    let url_ = this.baseUrl + "/api/TodoLists/Get/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "application/octet-stream",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet2(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet2(<any>response_);
            } catch (e) {
              return <Observable<FileResponse>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<FileResponse>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGet2(response: HttpResponseBase): Observable<FileResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get("content-disposition")
        : undefined;
      const fileNameMatch = contentDisposition
        ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
        : undefined;
      const fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[1]
          : undefined;
      return _observableOf({
        fileName: fileName,
        data: <any>responseBlob,
        status: status,
        headers: _headers,
      });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<FileResponse>(<any>null);
  }

  create(command: CreateTodoListCommand): Observable<number> {
    let url_ = this.baseUrl + "/api/TodoLists/Create";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(command);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        Accept: "application/json",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreate(<any>response_);
            } catch (e) {
              return <Observable<number>>(<any>_observableThrow(e));
            }
          } else return <Observable<number>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCreate(response: HttpResponseBase): Observable<number> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<number>(<any>null);
  }

  update(id: number, command: UpdateTodoListCommand): Observable<FileResponse> {
    let url_ = this.baseUrl + "/api/TodoLists/Update/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(command);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        Accept: "application/octet-stream",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<FileResponse>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<FileResponse>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdate(
    response: HttpResponseBase
  ): Observable<FileResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get("content-disposition")
        : undefined;
      const fileNameMatch = contentDisposition
        ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
        : undefined;
      const fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[1]
          : undefined;
      return _observableOf({
        fileName: fileName,
        data: <any>responseBlob,
        status: status,
        headers: _headers,
      });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<FileResponse>(<any>null);
  }

  delete(id: number): Observable<FileResponse> {
    let url_ = this.baseUrl + "/api/TodoLists/Delete/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "application/octet-stream",
      }),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<FileResponse>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<FileResponse>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(
    response: HttpResponseBase
  ): Observable<FileResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get("content-disposition")
        : undefined;
      const fileNameMatch = contentDisposition
        ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
        : undefined;
      const fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[1]
          : undefined;
      return _observableOf({
        fileName: fileName,
        data: <any>responseBlob,
        status: status,
        headers: _headers,
      });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<FileResponse>(<any>null);
  }
}

export interface IUserClient {
  getUserAll(): Observable<SimpleUser[]>;
  getUserAllPaged(
    query: GetAllUsersWithPage
  ): Observable<PaginatedListOfSimpleUser>;
  createUserSimple(query: CreateUserSimpleCommand): Observable<string>;
  getMyUserGroup(): Observable<UserGroup[]>;
  getAllUserRole(): Observable<UserRole[]>;
  getAllUserGroups(): Observable<UserGroup[]>;
  createUserRole(cmd: CreateUserRoleCommand): Observable<number>;
  updateUserRole(cmd: UpdateUserRoleCommand): Observable<number>;
  deleteUserRole(cmd: DeleteUserRoleCommand): Observable<boolean>;
  createUserGroup(cmd: CreateUserGroupCommand): Observable<number>;
  updateUserGroup(cmd: UpdateUserGroupCommand): Observable<number>;
  deleteUserGroup(cmd: DeleteUserGroupCommand): Observable<boolean>;
  getUserGroupById(cmd: GetUserGroupById): Observable<UserGroup>;
  getSimpleUserGroupById(id: number | undefined): Observable<UserGroupDto>;
  getRoleById(id: number | undefined): Observable<UserRole>;
  addGroupToUser(cmd: AddGroupToUserCommand): Observable<boolean>;
  getUserinfo(userId: string | null | undefined): Observable<UserGroup[]>;
  getUserGroupList(): Observable<UserGroupNameDto[]>;
  getSimpleUserGroup(
    userId: string | null | undefined
  ): Observable<UserGroupNameDto[]>;
  updateSimpleUserGroup(cmd: UpdateSimpleUserGroupCommand): Observable<number>;
}

@Injectable({
  providedIn: "root",
})
export class UserClient implements IUserClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  GetCallWithData<T>(url: string, data: any = {}): Observable<T> {
    return this.http.get<T>(this.baseUrl + url, { params: data });
  }

  PostCallWithData<T>(url: string, data: any = {}): Observable<T> {
    return this.http.post<T>(this.baseUrl + url, data);
  }

  getUserAll(): Observable<SimpleUser[]> {
    let url_ = this.baseUrl + "/api/User/GetUserAll";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetUserAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetUserAll(<any>response_);
            } catch (e) {
              return <Observable<SimpleUser[]>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<SimpleUser[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetUserAll(
    response: HttpResponseBase
  ): Observable<SimpleUser[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(SimpleUser.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    // return _observableOf<SimpleUser[]>(<any>null);
    return _observableOf();
  }

  getUserAllPaged(
    query: GetAllUsersWithPage
  ): Observable<PaginatedListOfSimpleUser> {
    let url_ = this.baseUrl + "/api/User/GetUserAllPaged";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(query);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        Accept: "application/json",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetUserAllPaged(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetUserAllPaged(<any>response_);
            } catch (e) {
              return <Observable<PaginatedListOfSimpleUser>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<PaginatedListOfSimpleUser>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetUserAllPaged(
    response: HttpResponseBase
  ): Observable<PaginatedListOfSimpleUser> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PaginatedListOfSimpleUser.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<PaginatedListOfSimpleUser>(<any>null);
  }

  createUserSimple(query: CreateUserSimpleCommand): Observable<string> {
    let url_ = this.baseUrl + "/api/User/CreateUserSimple";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(query);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        Accept: "application/json",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreateUserSimple(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreateUserSimple(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCreateUserSimple(
    response: HttpResponseBase
  ): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  getMyUserGroup(): Observable<UserGroup[]> {
    let url_ = this.baseUrl + "/api/User/GetMyUserGroup";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetMyUserGroup(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetMyUserGroup(<any>response_);
            } catch (e) {
              return <Observable<UserGroup[]>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<UserGroup[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetMyUserGroup(
    response: HttpResponseBase
  ): Observable<UserGroup[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(UserGroup.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    // return _observableOf<UserGroup[]>(<any>null);
    return _observableOf();
  }

  getAllUserRole(): Observable<UserRole[]> {
    let url_ = this.baseUrl + "/api/User/GetAllUserRole";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllUserRole(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllUserRole(<any>response_);
            } catch (e) {
              return <Observable<UserRole[]>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<UserRole[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAllUserRole(
    response: HttpResponseBase
  ): Observable<UserRole[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(UserRole.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    // return _observableOf<UserRole[]>(<any>null);
    return _observableOf();
  }

  getAllUserGroups(): Observable<UserGroup[]> {
    let url_ = this.baseUrl + "/api/User/GetAllUserGroups";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllUserGroups(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllUserGroups(<any>response_);
            } catch (e) {
              return <Observable<UserGroup[]>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<UserGroup[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAllUserGroups(
    response: HttpResponseBase
  ): Observable<UserGroup[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(UserGroup.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    // return _observableOf<UserGroup[]>(<any>null);
    return _observableOf();
  }

  createUserRole(cmd: CreateUserRoleCommand): Observable<number> {
    let url_ = this.baseUrl + "/api/User/CreateUserRole";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(cmd);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        Accept: "application/json",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreateUserRole(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreateUserRole(<any>response_);
            } catch (e) {
              return <Observable<number>>(<any>_observableThrow(e));
            }
          } else return <Observable<number>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCreateUserRole(
    response: HttpResponseBase
  ): Observable<number> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<number>(<any>null);
  }

  updateUserRole(cmd: UpdateUserRoleCommand): Observable<number> {
    let url_ = this.baseUrl + "/api/User/UpdateUserRole";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(cmd);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        Accept: "application/json",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdateUserRole(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdateUserRole(<any>response_);
            } catch (e) {
              return <Observable<number>>(<any>_observableThrow(e));
            }
          } else return <Observable<number>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdateUserRole(
    response: HttpResponseBase
  ): Observable<number> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<number>(<any>null);
  }

  deleteUserRole(cmd: DeleteUserRoleCommand): Observable<boolean> {
    let url_ = this.baseUrl + "/api/User/DeleteUserRole";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(cmd);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        Accept: "application/json",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDeleteUserRole(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDeleteUserRole(<any>response_);
            } catch (e) {
              return <Observable<boolean>>(<any>_observableThrow(e));
            }
          } else return <Observable<boolean>>(<any>_observableThrow(response_));
        })
      );
  }

  deleteUserRoles(lstIds: Array<number>): Observable<boolean> {
    const content_ = JSON.stringify(lstIds);
    let url_ = this.baseUrl + "/api/User/DeleteUserRoles";

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        Accept: "application/json",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDeleteUserRole(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDeleteUserRole(<any>response_);
            } catch (e) {
              return <Observable<boolean>>(<any>_observableThrow(e));
            }
          } else return <Observable<boolean>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDeleteUserRole(
    response: HttpResponseBase
  ): Observable<boolean> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<boolean>(<any>null);
  }

  createUserGroup(cmd: CreateUserGroupCommand): Observable<number> {
    let url_ = this.baseUrl + "/api/User/CreateUserGroup";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(cmd);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        Accept: "application/json",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreateUserGroup(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreateUserGroup(<any>response_);
            } catch (e) {
              return <Observable<number>>(<any>_observableThrow(e));
            }
          } else return <Observable<number>>(<any>_observableThrow(response_));
        })
      );
  }

  getUserInfo(): Observable<any> {
    return this.http.get(`${this.baseUrl + "/api/User/GetUserDetail"}`);
  }
  getaudit(): Observable<any> {
    return this.http.get(`${this.baseUrl + "/api/Audit/GetAuditInfo"}`);
  }

  // getUserInfo(): Observable<UserInfomodel[]> {
  //   let url_ = this.baseUrl + "/api/User/GetUserInfo";
  //   url_ = url_.replace(/[?&]$/, "");

  //   let options_: any = {
  //     observe: "response",
  //     responseType: "blob",
  //     headers: new HttpHeaders({
  //       Accept: "application/json",
  //     }),
  //   };

  //   return this.http
  //     .request("get", url_, options_)
  //     .pipe(
  //       _observableMergeMap((response_: any) => {
  //         return this.processgetUserInfo(response_);
  //       })
  //     )
  //     .pipe(
  //       _observableCatch((response_: any) => {
  //         if (response_ instanceof HttpResponseBase) {
  //           try {
  //             return this.processgetUserInfo(<any>response_);
  //           } catch (e) {
  //             return <Observable<UserInfomodel[]>>(
  //               (<any>_observableThrow(e))
  //             );
  //           }
  //         } else
  //           return <Observable<UserInfomodel[]>>(
  //             (<any>_observableThrow(response_))
  //           );
  //       })
  //     );
  // }

  // protected processgetUserInfo(
  //   response: HttpResponseBase
  // ): Observable<UserInfomodel[]> {
  //   console.log(response);
  //   const status = response.status;
  //   const responseBlob =
  //     response instanceof HttpResponse
  //       ? response.body
  //       : (<any>response).error instanceof Blob
  //       ? (<any>response).error
  //       : undefined;

  //   let _headers: any = {};
  //   if (response.headers) {
  //     for (let key of response.headers.keys()) {
  //       _headers[key] = response.headers.get(key);
  //     }
  //   }
  //   if (status === 200) {
  //     return blobToText(responseBlob).pipe(
  //       _observableMergeMap((_responseText) => {
  //         let result200: any = null;
  //         let resultData200 =
  //           _responseText === ""
  //             ? null
  //             : JSON.parse(_responseText, this.jsonParseReviver);
  //         // if (Array.isArray(resultData200)) {
  //         //   result200 = [] as any;
  //         //   for (let item of resultData200)
  //         //     //result200!.push(UserInfomodel.fromJS(item));
  //         // } else {
  //         //   result200 = <any>null;
  //         // }
  //         return _observableOf(result200);
  //       })
  //     );
  //   } else if (status !== 200 && status !== 204) {
  //     return blobToText(responseBlob).pipe(
  //       _observableMergeMap((_responseText) => {
  //         return throwException(
  //           "An unexpected server error occurred.",
  //           status,
  //           _responseText,
  //           _headers
  //         );
  //       })
  //     );
  //   }
  //   return _observableOf<UserInfomodel[]>(<any>null);
  // }

  protected processCreateUserGroup(
    response: HttpResponseBase
  ): Observable<number> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<number>(<any>null);
  }

  updateUserGroup(cmd: UpdateUserGroupCommand): Observable<number> {
    let url_ = this.baseUrl + "/api/User/UpdateUserGroup";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(cmd);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        Accept: "application/json",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdateUserGroup(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdateUserGroup(<any>response_);
            } catch (e) {
              return <Observable<number>>(<any>_observableThrow(e));
            }
          } else return <Observable<number>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdateUserGroup(
    response: HttpResponseBase
  ): Observable<number> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<number>(<any>null);
  }

  deleteUserGroup(cmd: DeleteUserGroupCommand): Observable<boolean> {
    let url_ = this.baseUrl + "/api/User/DeleteUserGroup";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(cmd);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        Accept: "application/json",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDeleteUserGroup(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDeleteUserGroup(<any>response_);
            } catch (e) {
              return <Observable<boolean>>(<any>_observableThrow(e));
            }
          } else return <Observable<boolean>>(<any>_observableThrow(response_));
        })
      );
  }

  deleteUserGroups(lstIds: Array<number>): Observable<boolean> {
    const content_ = JSON.stringify(lstIds);
    let url_ = this.baseUrl + "/api/User/DeleteUserGroups";

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        Accept: "application/json",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDeleteUserGroup(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDeleteUserGroup(<any>response_);
            } catch (e) {
              return <Observable<boolean>>(<any>_observableThrow(e));
            }
          } else return <Observable<boolean>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDeleteUserGroup(
    response: HttpResponseBase
  ): Observable<boolean> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<boolean>(<any>null);
  }

  getUserGroupById(cmd: GetUserGroupById): Observable<UserGroup> {
    let url_ = this.baseUrl + "/api/User/GetUserGroupById";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(cmd);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        Accept: "application/json",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetUserGroupById(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetUserGroupById(<any>response_);
            } catch (e) {
              return <Observable<UserGroup>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<UserGroup>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetUserGroupById(
    response: HttpResponseBase
  ): Observable<UserGroup> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = UserGroup.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<UserGroup>(<any>null);
  }

  getSimpleUserGroupById(id: number | undefined): Observable<UserGroupDto> {
    let url_ = this.baseUrl + "/api/User/GetSimpleUserGroupById?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetSimpleUserGroupById(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetSimpleUserGroupById(<any>response_);
            } catch (e) {
              return <Observable<UserGroupDto>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<UserGroupDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetSimpleUserGroupById(
    response: HttpResponseBase
  ): Observable<UserGroupDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = UserGroupDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<UserGroupDto>(<any>null);
  }

  getRoleById(id: number | undefined): Observable<UserRole> {
    let url_ = this.baseUrl + "/api/User/GetRoleById?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetRoleById(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetRoleById(<any>response_);
            } catch (e) {
              return <Observable<UserRole>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<UserRole>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetRoleById(
    response: HttpResponseBase
  ): Observable<UserRole> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = UserRole.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<UserRole>(<any>null);
  }

  addGroupToUser(cmd: AddGroupToUserCommand): Observable<boolean> {
    let url_ = this.baseUrl + "/api/User/AddGroupToUser";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(cmd);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        Accept: "application/json",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAddGroupToUser(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAddGroupToUser(<any>response_);
            } catch (e) {
              return <Observable<boolean>>(<any>_observableThrow(e));
            }
          } else return <Observable<boolean>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAddGroupToUser(
    response: HttpResponseBase
  ): Observable<boolean> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<boolean>(<any>null);
  }

  getUserinfo(userId: string | null | undefined): Observable<UserGroup[]> {
    let url_ = this.baseUrl + "/api/User/GetUserinfo?";
    if (userId !== undefined && userId !== null)
      url_ += "userId=" + encodeURIComponent("" + userId) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetUserinfo(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetUserinfo(<any>response_);
            } catch (e) {
              return <Observable<UserGroup[]>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<UserGroup[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetUserinfo(
    response: HttpResponseBase
  ): Observable<UserGroup[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(UserGroup.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    // return _observableOf<UserGroup[]>(<any>null);
    return _observableOf();
  }

  getUserGroupList(): Observable<UserGroupNameDto[]> {
    let url_ = this.baseUrl + "/api/User/GetUserGroupList";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetUserGroupList(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetUserGroupList(<any>response_);
            } catch (e) {
              return <Observable<UserGroupNameDto[]>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<UserGroupNameDto[]>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetUserGroupList(
    response: HttpResponseBase
  ): Observable<UserGroupNameDto[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(UserGroupNameDto.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    // return _observableOf<UserGroupNameDto[]>(<any>null);
    return _observableOf();
  }

  getSimpleUserGroup(
    userId: string | null | undefined
  ): Observable<UserGroupNameDto[]> {
    let url_ = this.baseUrl + "/api/User/GetSimpleUserGroup?";
    if (userId !== undefined && userId !== null)
      url_ += "userId=" + encodeURIComponent("" + userId) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetSimpleUserGroup(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetSimpleUserGroup(<any>response_);
            } catch (e) {
              return <Observable<UserGroupNameDto[]>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<UserGroupNameDto[]>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetSimpleUserGroup(
    response: HttpResponseBase
  ): Observable<UserGroupNameDto[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(UserGroupNameDto.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    // return _observableOf<UserGroupNameDto[]>(<any>null);
    return _observableOf();
  }

  updateSimpleUserGroup(cmd: UpdateSimpleUserGroupCommand): Observable<number> {
    let url_ = this.baseUrl + "/api/User/UpdateSimpleUserGroup";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(cmd);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        Accept: "application/json",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdateSimpleUserGroup(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdateSimpleUserGroup(<any>response_);
            } catch (e) {
              return <Observable<number>>(<any>_observableThrow(e));
            }
          } else return <Observable<number>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdateSimpleUserGroup(
    response: HttpResponseBase
  ): Observable<number> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<number>(<any>null);
  }
}

export interface IUserPermissionClient {
  getPermissionNameList(): Observable<UserPermissionDto[]>;
  createPermissionSet(cmd: CreatePermissionSetCommand): Observable<number>;
  deletePermissionSet(cmd: DeletePermissionSetCommand): Observable<boolean>;
  updatePermissionSet(cmd: UpdatePermissionSetCommand): Observable<number>;
  getPermissionSetList(): Observable<PermissionSet[]>;
  getMySystemPermission(): Observable<PermissionSet[]>;
  getMyRoomsPermission(): Observable<UserGroup[]>;
  getOnePermissionSetQuery(
    setId: number | undefined
  ): Observable<PermissionSet>;
  getPermissionSetNameList(): Observable<(PermissionSetDto | undefined)[]>;
}

@Injectable({
  providedIn: "root",
})
export class UserPermissionClient implements IUserPermissionClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  getPermissionNameList(): Observable<UserPermissionDto[]> {
    let url_ = this.baseUrl + "/api/UserPermission/GetPermissionNameList";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetPermissionNameList(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetPermissionNameList(<any>response_);
            } catch (e) {
              return <Observable<UserPermissionDto[]>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<UserPermissionDto[]>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetPermissionNameList(
    response: HttpResponseBase
  ): Observable<UserPermissionDto[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(UserPermissionDto.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    // return _observableOf<UserPermissionDto[]>(<any>null);
    return _observableOf();
  }

  createPermissionSet(cmd: CreatePermissionSetCommand): Observable<number> {
    let url_ = this.baseUrl + "/api/UserPermission/CreatePermissionSet";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(cmd);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        Accept: "application/json",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreatePermissionSet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreatePermissionSet(<any>response_);
            } catch (e) {
              return <Observable<number>>(<any>_observableThrow(e));
            }
          } else return <Observable<number>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCreatePermissionSet(
    response: HttpResponseBase
  ): Observable<number> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<number>(<any>null);
  }

  deletePermissionSets(lstIds: Array<number>): Observable<boolean> {
    const content_ = JSON.stringify(lstIds);
    let url_ = this.baseUrl + "/api/UserPermission/DeletePermissionSets";

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        Accept: "application/json",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDeletePermissionSet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDeletePermissionSet(<any>response_);
            } catch (e) {
              return <Observable<boolean>>(<any>_observableThrow(e));
            }
          } else return <Observable<boolean>>(<any>_observableThrow(response_));
        })
      );
  }

  deletePermissionSet(cmd: DeletePermissionSetCommand): Observable<boolean> {
    let url_ = this.baseUrl + "/api/UserPermission/DeletePermissionSet";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(cmd);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        Accept: "application/json",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDeletePermissionSet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDeletePermissionSet(<any>response_);
            } catch (e) {
              return <Observable<boolean>>(<any>_observableThrow(e));
            }
          } else return <Observable<boolean>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDeletePermissionSet(
    response: HttpResponseBase
  ): Observable<boolean> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<boolean>(<any>null);
  }

  updatePermissionSet(cmd: UpdatePermissionSetCommand): Observable<number> {
    let url_ = this.baseUrl + "/api/UserPermission/UpdatePermissionSet";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(cmd);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        Accept: "application/json",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdatePermissionSet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdatePermissionSet(<any>response_);
            } catch (e) {
              return <Observable<number>>(<any>_observableThrow(e));
            }
          } else return <Observable<number>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdatePermissionSet(
    response: HttpResponseBase
  ): Observable<number> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<number>(<any>null);
  }

  getPermissionSetList(): Observable<PermissionSet[]> {
    let url_ = this.baseUrl + "/api/UserPermission/GetPermissionSetList";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetPermissionSetList(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetPermissionSetList(<any>response_);
            } catch (e) {
              return <Observable<PermissionSet[]>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<PermissionSet[]>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetPermissionSetList(
    response: HttpResponseBase
  ): Observable<PermissionSet[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(PermissionSet.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    // return _observableOf<PermissionSet[]>(<any>null);
    return _observableOf();
  }

  getMySystemPermission(): Observable<PermissionSet[]> {
    let url_ = this.baseUrl + "/api/UserPermission/GetMySystemPermission";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetMySystemPermission(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetMySystemPermission(<any>response_);
            } catch (e) {
              return <Observable<PermissionSet[]>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<PermissionSet[]>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetMySystemPermission(
    response: HttpResponseBase
  ): Observable<PermissionSet[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(PermissionSet.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    // return _observableOf<PermissionSet[]>(<any>null);
    return _observableOf();
  }

  getMyRoomsPermission(): Observable<UserGroup[]> {
    let url_ = this.baseUrl + "/api/UserPermission/GetMyRoomsPermission";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetMyRoomsPermission(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetMyRoomsPermission(<any>response_);
            } catch (e) {
              return <Observable<UserGroup[]>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<UserGroup[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetMyRoomsPermission(
    response: HttpResponseBase
  ): Observable<UserGroup[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(UserGroup.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    // return _observableOf<UserGroup[]>(<any>null);
    return _observableOf();
  }

  getOnePermissionSetQuery(
    setId: number | undefined
  ): Observable<PermissionSet> {
    let url_ = this.baseUrl + "/api/UserPermission/GetOnePermissionSetQuery?";
    if (setId === null)
      throw new Error("The parameter 'setId' cannot be null.");
    else if (setId !== undefined)
      url_ += "setId=" + encodeURIComponent("" + setId) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetOnePermissionSetQuery(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetOnePermissionSetQuery(<any>response_);
            } catch (e) {
              return <Observable<PermissionSet>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<PermissionSet>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetOnePermissionSetQuery(
    response: HttpResponseBase
  ): Observable<PermissionSet> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PermissionSet.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<PermissionSet>(<any>null);
  }

  getPermissionSetNameList(): Observable<(PermissionSetDto | undefined)[]> {
    let url_ = this.baseUrl + "/api/UserPermission/GetPermissionSetNameList";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetPermissionSetNameList(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetPermissionSetNameList(<any>response_);
            } catch (e) {
              return <Observable<(PermissionSetDto | undefined)[]>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<(PermissionSetDto | undefined)[]>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetPermissionSetNameList(
    response: HttpResponseBase
  ): Observable<(PermissionSetDto | undefined)[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(PermissionSetDto.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    // return _observableOf<(PermissionSetDto | undefined)[]>(<any>null);
    return _observableOf();
  }
}

export interface IWeatherForecastClient {
  get(cmd: GetWeatherForecastsQuery): Observable<WeatherForecast[]>;
}

@Injectable({
  providedIn: "root",
})
export class WeatherForecastClient implements IWeatherForecastClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  get(cmd: GetWeatherForecastsQuery): Observable<WeatherForecast[]> {
    let url_ = this.baseUrl + "/api/WeatherForecast/Get";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(cmd);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        Accept: "application/json",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(<any>response_);
            } catch (e) {
              return <Observable<WeatherForecast[]>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<WeatherForecast[]>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGet(
    response: HttpResponseBase
  ): Observable<WeatherForecast[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(WeatherForecast.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    // return _observableOf<WeatherForecast[]>(<any>null);
    return _observableOf();
  }
}
export class UserInfomodel {
  UserName: string;
  NormalizedUserName: string;
  NormalizedEmail: string;
  PhoneNumber: string;
}

export class SimpleBookingDto implements ISimpleBookingDto {
  editable?: boolean;
  viewable?: boolean;
  start?: Date;
  end?: Date;
  infoCode?: string | undefined;
  resourceId?: number;
  roomId?: number;
  title?: string | undefined;
  color?: string | undefined;
  status?: BookingStatus;
  bookingType?: BookingType;
  bookingId?: number;
  description?: string | undefined;
  isAvailable?: boolean;

  constructor(data?: ISimpleBookingDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.editable = _data["editable"];
      this.viewable = _data["viewable"];
      this.start = _data["start"]
        ? new Date(_data["start"].toString())
        : <any>undefined;
      this.end = _data["end"]
        ? new Date(_data["end"].toString())
        : <any>undefined;
      this.infoCode = _data["infoCode"];
      this.resourceId = _data["resourceId"];
      this.roomId = _data["roomId"];
      this.title = _data["title"];
      this.color = _data["color"];
      this.status = _data["status"];
      this.bookingType = _data["bookingType"];
      this.bookingId = _data["bookingId"];
      this.description = _data["description"];
      this.isAvailable = _data["isAvailable"];
    }
  }

  static fromJS(data: any): SimpleBookingDto {
    data = typeof data === "object" ? data : {};
    let result = new SimpleBookingDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["editable"] = this.editable;
    data["viewable"] = this.viewable;
    data["start"] = this.start ? this.start.toISOString() : <any>undefined;
    data["end"] = this.end ? this.end.toISOString() : <any>undefined;
    data["infoCode"] = this.infoCode;
    data["resourceId"] = this.resourceId;
    data["roomId"] = this.roomId;
    data["title"] = this.title;
    data["color"] = this.color;
    data["status"] = this.status;
    data["bookingType"] = this.bookingType;
    data["bookingId"] = this.bookingId;
    data["description"] = this.description;
    data["isAvailable"] = this.isAvailable;
    return data;
  }
}

export interface ISimpleBookingDto {
  editable?: boolean;
  viewable?: boolean;
  start?: Date;
  end?: Date;
  infoCode?: string | undefined;
  resourceId?: number;
  roomId?: number;
  title?: string | undefined;
  color?: string | undefined;
  status?: BookingStatus;
  bookingType?: BookingType;
  bookingId?: number;
  description?: string | undefined;
}

export enum BookingStatus {
  Confirmed = 1,
  Finished = 2,
  NoShow = 3,
  Stage1 = 4,
  Stage2 = 5,
  Stage3 = 6,
  Cancelled = 7,
  Rejected = 8,
  Class = 9,
  ForBooking = 10,
}

export enum BookingType {
  Closed = 1,
  AnyoneWithCard = 2,
  UserWithCard = 3,
  FreeAccess = 4,
}

export class GetAvailableBookingCommand implements IGetAvailableBookingCommand {
  roomIds?: number[] | undefined;
  start?: Date;
  end?: Date;

  constructor(data?: IGetAvailableBookingCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["roomIds"])) {
        this.roomIds = [] as any;
        for (let item of _data["roomIds"]) this.roomIds!.push(item);
      }
      this.start = _data["start"]
        ? new Date(_data["start"].toString())
        : <any>undefined;
      this.end = _data["end"]
        ? new Date(_data["end"].toString())
        : <any>undefined;
    }
  }

  static fromJS(data: any): GetAvailableBookingCommand {
    data = typeof data === "object" ? data : {};
    let result = new GetAvailableBookingCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.roomIds)) {
      data["roomIds"] = [];
      for (let item of this.roomIds) data["roomIds"].push(item);
    }
    data["start"] = this.start ? this.start.toISOString() : <any>undefined;
    data["end"] = this.end ? this.end.toISOString() : <any>undefined;
    return data;
  }
}

export class GetFirstAvailableBookingCommand
  implements IGetAvailableBookingCommand
{
  roomId?: number | undefined;
  start?: Date;
  end?: Date;

  constructor(data?: IGetAvailableBookingCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.roomId = _data["roomId"];
      this.start = _data["start"]
        ? new Date(_data["start"].toString())
        : <any>undefined;
      this.end = _data["end"]
        ? new Date(_data["end"].toString())
        : <any>undefined;
    }
  }

  static fromJS(data: any): GetAvailableBookingCommand {
    data = typeof data === "object" ? data : {};
    let result = new GetAvailableBookingCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["roomId"] = this.roomId;
    data["start"] = this.start ? this.start.toISOString() : <any>undefined;
    data["end"] = this.end ? this.end.toISOString() : <any>undefined;
    return data;
  }
}

export interface IGetAvailableBookingCommand {
  roomIds?: number[] | undefined;
  start?: Date;
  end?: Date;
}

export class CreateSimpleBookingCommand implements ICreateSimpleBookingCommand {
  name?: string | undefined;
  names?: string[] | undefined;
  bookingDetailDto?: BookingDetailDto | undefined;
  date?: Date;
  startTime?: Date;
  endTime?: Date;
  bookingType?: BookingType;
  roomId?: number;

  constructor(data?: ICreateSimpleBookingCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data["name"];
      if (Array.isArray(_data["names"])) {
        this.names = [] as any;
        for (let item of _data["names"]) this.names!.push(item);
      }
      this.bookingDetailDto = _data["bookingDetailDto"]
        ? BookingDetailDto.fromJS(_data["bookingDetailDto"])
        : <any>undefined;
      this.date = _data["date"]
        ? new Date(_data["date"].toString())
        : <any>undefined;
      this.startTime = _data["startTime"]
        ? new Date(_data["startTime"].toString())
        : <any>undefined;
      this.endTime = _data["endTime"]
        ? new Date(_data["endTime"].toString())
        : <any>undefined;
      this.bookingType = _data["bookingType"];
      this.roomId = _data["roomId"];
    }
  }

  static fromJS(data: any): CreateSimpleBookingCommand {
    data = typeof data === "object" ? data : {};
    let result = new CreateSimpleBookingCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["name"] = this.name;
    if (Array.isArray(this.names)) {
      data["names"] = [];
      for (let item of this.names) data["names"].push(item);
    }
    data["bookingDetailDto"] = this.bookingDetailDto
      ? this.bookingDetailDto.toJSON()
      : <any>undefined;
    data["date"] = this.date ? this.date.toISOString() : <any>undefined;
    data["startTime"] = this.startTime
      ? this.startTime.toISOString()
      : <any>undefined;
    data["endTime"] = this.endTime
      ? this.endTime.toISOString()
      : <any>undefined;
    data["bookingType"] = this.bookingType;
    data["roomId"] = this.roomId;
    return data;
  }
}

export interface ICreateSimpleBookingCommand {
  name?: string | undefined;
  names?: string[] | undefined;
  bookingDetailDto?: BookingDetailDto | undefined;
  date?: Date;
  startTime?: Date;
  endTime?: Date;
  bookingType?: BookingType;
  roomId?: number;
}

export class BookingDetailDto implements IBookingDetailDto {
  description?: string | undefined;
  equipmentsID?: string[] | undefined;
  customFields?: CustomField[] | undefined;

  constructor(data?: IBookingDetailDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.description = _data["description"];
      if (Array.isArray(_data["equipmentsID"])) {
        this.equipmentsID = [] as any;
        for (let item of _data["equipmentsID"]) this.equipmentsID!.push(item);
      }
      if (Array.isArray(_data["customFields"])) {
        this.customFields = [] as any;
        for (let item of _data["customFields"])
          this.customFields!.push(CustomField.fromJS(item));
      }
    }
  }

  static fromJS(data: any): BookingDetailDto {
    data = typeof data === "object" ? data : {};
    let result = new BookingDetailDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["description"] = this.description;
    if (Array.isArray(this.equipmentsID)) {
      data["equipmentsID"] = [];
      for (let item of this.equipmentsID) data["equipmentsID"].push(item);
    }
    if (Array.isArray(this.customFields)) {
      data["customFields"] = [];
      for (let item of this.customFields)
        data["customFields"].push(item.toJSON());
    }
    return data;
  }
}

export interface IBookingDetailDto {
  description?: string | undefined;
  equipmentsID?: string[] | undefined;
  customFields?: CustomField[] | undefined;
}

export class CustomField implements ICustomField {
  key?: string | undefined;
  value?: string | undefined;

  constructor(data?: ICustomField) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.key = _data["key"];
      this.value = _data["value"];
    }
  }

  static fromJS(data: any): CustomField {
    data = typeof data === "object" ? data : {};
    let result = new CustomField();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["key"] = this.key;
    data["value"] = this.value;
    return data;
  }
}

export interface ICustomField {
  key?: string | undefined;
  value?: string | undefined;
}

export abstract class AuditableEntity implements IAuditableEntity {
  created?: Date;
  createdBy?: string | undefined;
  lastModified?: Date | undefined;
  lastModifiedBy?: string | undefined;

  constructor(data?: IAuditableEntity) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.created = _data["created"]
        ? new Date(_data["created"].toString())
        : <any>undefined;
      this.createdBy = _data["createdBy"];
      this.lastModified = _data["lastModified"]
        ? new Date(_data["lastModified"].toString())
        : <any>undefined;
      this.lastModifiedBy = _data["lastModifiedBy"];
    }
  }

  static fromJS(data: any): AuditableEntity {
    data = typeof data === "object" ? data : {};
    throw new Error(
      "The abstract class 'AuditableEntity' cannot be instantiated."
    );
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["created"] = this.created
      ? this.created.toISOString()
      : <any>undefined;
    data["createdBy"] = this.createdBy;
    data["lastModified"] = this.lastModified
      ? this.lastModified.toISOString()
      : <any>undefined;
    data["lastModifiedBy"] = this.lastModifiedBy;
    return data;
  }
}

export interface IAuditableEntity {
  created?: Date;
  createdBy?: string | undefined;
  lastModified?: Date | undefined;
  lastModifiedBy?: string | undefined;
}

export class Booking extends AuditableEntity implements IBooking {
  id?: number;
  isChecked?: boolean;
  bookingStatus?: BookingStatus;
  bookingDetails?: BookingDetails | undefined;
  bookingDetailsId?: number;
  start?: Date;
  end?: Date;
  bookingType?: BookingType;
  room?: Room | undefined;
  roomId?: number | undefined;
  bookingApplicationUser?: BookingApplicationUser[] | undefined;

  constructor(data?: IBooking) {
    super(data);
  }

  init(_data?: any) {
    super.init(_data);
    if (_data) {
      this.id = _data["id"];
      this.bookingStatus = _data["bookingStatus"];
      this.bookingDetails = _data["bookingDetails"]
        ? BookingDetails.fromJS(_data["bookingDetails"])
        : <any>undefined;
      this.bookingDetailsId = _data["bookingDetailsId"];
      this.start = _data["start"]
        ? new Date(_data["start"].toString())
        : <any>undefined;
      this.end = _data["end"]
        ? new Date(_data["end"].toString())
        : <any>undefined;
      this.bookingType = _data["bookingType"];
      this.room = _data["room"] ? Room.fromJS(_data["room"]) : <any>undefined;
      this.roomId = _data["roomId"];
      if (Array.isArray(_data["bookingApplicationUser"])) {
        this.bookingApplicationUser = [] as any;
        for (let item of _data["bookingApplicationUser"])
          this.bookingApplicationUser!.push(
            BookingApplicationUser.fromJS(item)
          );
      }
    }
  }

  static fromJS(data: any): Booking {
    data = typeof data === "object" ? data : {};
    let result = new Booking();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["bookingStatus"] = this.bookingStatus;
    data["bookingDetails"] = this.bookingDetails
      ? this.bookingDetails.toJSON()
      : <any>undefined;
    data["bookingDetailsId"] = this.bookingDetailsId;
    data["start"] = this.start ? this.start.toISOString() : <any>undefined;
    data["end"] = this.end ? this.end.toISOString() : <any>undefined;
    data["bookingType"] = this.bookingType;
    data["room"] = this.room ? this.room.toJSON() : <any>undefined;
    data["roomId"] = this.roomId;
    if (Array.isArray(this.bookingApplicationUser)) {
      data["bookingApplicationUser"] = [];
      for (let item of this.bookingApplicationUser)
        data["bookingApplicationUser"].push(item.toJSON());
    }
    super.toJSON(data);
    return data;
  }
}

export interface IBooking extends IAuditableEntity {
  id?: number;
  bookingStatus?: BookingStatus;
  bookingDetails?: BookingDetails | undefined;
  bookingDetailsId?: number;
  start?: Date;
  end?: Date;
  bookingType?: BookingType;
  room?: Room | undefined;
  roomId?: number | undefined;
  bookingApplicationUser?: BookingApplicationUser[] | undefined;
}

export class BookingDetails implements IBookingDetails {
  id?: number;
  users?: string[] | undefined;
  description?: string | undefined;
  equipments?: Equipment[] | undefined;

  constructor(data?: IBookingDetails) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      if (Array.isArray(_data["users"])) {
        this.users = [] as any;
        for (let item of _data["users"]) this.users!.push(item);
      }
      this.description = _data["description"];
      if (Array.isArray(_data["equipments"])) {
        this.equipments = [] as any;
        for (let item of _data["equipments"])
          this.equipments!.push(Equipment.fromJS(item));
      }
    }
  }

  static fromJS(data: any): BookingDetails {
    data = typeof data === "object" ? data : {};
    let result = new BookingDetails();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    if (Array.isArray(this.users)) {
      data["users"] = [];
      for (let item of this.users) data["users"].push(item);
    }
    data["description"] = this.description;
    if (Array.isArray(this.equipments)) {
      data["equipments"] = [];
      for (let item of this.equipments) data["equipments"].push(item.toJSON());
    }
    return data;
  }
}

export interface IBookingDetails {
  id?: number;
  users?: string[] | undefined;
  description?: string | undefined;
  equipments?: Equipment[] | undefined;
}

export class Equipment extends AuditableEntity implements IEquipment {
  id?: number;
  name?: string | undefined;
  departmentId?: number | undefined;
  count?: number;
  maxCount?: number;
  bookingDetailsList?: BookingDetails[] | undefined;
  equipmentLoans?: EquipmentLoan[] | undefined;

  constructor(data?: IEquipment) {
    super(data);
  }

  init(_data?: any) {
    super.init(_data);
    if (_data) {
      this.id = _data["id"];
      this.name = _data["name"];
      this.departmentId = _data["departmentId"];
      this.count = _data["count"];
      this.maxCount = _data["maxCount"];
      if (Array.isArray(_data["bookingDetailsList"])) {
        this.bookingDetailsList = [] as any;
        for (let item of _data["bookingDetailsList"])
          this.bookingDetailsList!.push(BookingDetails.fromJS(item));
      }
      if (Array.isArray(_data["equipmentLoans"])) {
        this.equipmentLoans = [] as any;
        for (let item of _data["equipmentLoans"])
          this.equipmentLoans!.push(EquipmentLoan.fromJS(item));
      }
    }
  }

  static fromJS(data: any): Equipment {
    data = typeof data === "object" ? data : {};
    let result = new Equipment();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["name"] = this.name;
    data["departmentId"] = this.departmentId;
    data["count"] = this.count;
    data["maxCount"] = this.maxCount;
    if (Array.isArray(this.bookingDetailsList)) {
      data["bookingDetailsList"] = [];
      for (let item of this.bookingDetailsList)
        data["bookingDetailsList"].push(item.toJSON());
    }
    if (Array.isArray(this.equipmentLoans)) {
      data["equipmentLoans"] = [];
      for (let item of this.equipmentLoans)
        data["equipmentLoans"].push(item.toJSON());
    }
    super.toJSON(data);
    return data;
  }
}

export interface IEquipment extends IAuditableEntity {
  id?: number;
  name?: string | undefined;
  departmentId?: number | undefined;
  count?: number;
  maxCount?: number;
  bookingDetailsList?: BookingDetails[] | undefined;
  equipmentLoans?: EquipmentLoan[] | undefined;
}

export class EquipmentLoan implements IEquipmentLoan {
  id?: number;
  booking?: Booking | undefined;
  loanDate?: Date;
  returnDate?: Date | undefined;
  equipmentList?: Equipment[] | undefined;
  userContacts?: Contact[] | undefined;
  staffContacts?: Contact[] | undefined;

  constructor(data?: IEquipmentLoan) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.booking = _data["booking"]
        ? Booking.fromJS(_data["booking"])
        : <any>undefined;
      this.loanDate = _data["loanDate"]
        ? new Date(_data["loanDate"].toString())
        : <any>undefined;
      this.returnDate = _data["returnDate"]
        ? new Date(_data["returnDate"].toString())
        : <any>undefined;
      if (Array.isArray(_data["equipmentList"])) {
        this.equipmentList = [] as any;
        for (let item of _data["equipmentList"])
          this.equipmentList!.push(Equipment.fromJS(item));
      }
      if (Array.isArray(_data["userContacts"])) {
        this.userContacts = [] as any;
        for (let item of _data["userContacts"])
          this.userContacts!.push(Contact.fromJS(item));
      }
      if (Array.isArray(_data["staffContacts"])) {
        this.staffContacts = [] as any;
        for (let item of _data["staffContacts"])
          this.staffContacts!.push(Contact.fromJS(item));
      }
    }
  }

  static fromJS(data: any): EquipmentLoan {
    data = typeof data === "object" ? data : {};
    let result = new EquipmentLoan();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["booking"] = this.booking ? this.booking.toJSON() : <any>undefined;
    data["loanDate"] = this.loanDate
      ? this.loanDate.toISOString()
      : <any>undefined;
    data["returnDate"] = this.returnDate
      ? this.returnDate.toISOString()
      : <any>undefined;
    if (Array.isArray(this.equipmentList)) {
      data["equipmentList"] = [];
      for (let item of this.equipmentList)
        data["equipmentList"].push(item.toJSON());
    }
    if (Array.isArray(this.userContacts)) {
      data["userContacts"] = [];
      for (let item of this.userContacts)
        data["userContacts"].push(item.toJSON());
    }
    if (Array.isArray(this.staffContacts)) {
      data["staffContacts"] = [];
      for (let item of this.staffContacts)
        data["staffContacts"].push(item.toJSON());
    }
    return data;
  }
}

export interface IEquipmentLoan {
  id?: number;
  booking?: Booking | undefined;
  loanDate?: Date;
  returnDate?: Date | undefined;
  equipmentList?: Equipment[] | undefined;
  userContacts?: Contact[] | undefined;
  staffContacts?: Contact[] | undefined;
}

export class Contact implements IContact {
  id?: number;
  phone?: string | undefined;
  userCode?: string | undefined;
  email?: string | undefined;

  constructor(data?: IContact) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.phone = _data["phone"];
      this.userCode = _data["userCode"];
      this.email = _data["email"];
    }
  }

  static fromJS(data: any): Contact {
    data = typeof data === "object" ? data : {};
    let result = new Contact();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["phone"] = this.phone;
    data["userCode"] = this.userCode;
    data["email"] = this.email;
    return data;
  }
}

export interface IContact {
  id?: number;
  phone?: string | undefined;
  userCode?: string | undefined;
  email?: string | undefined;
}

export class Room extends AuditableEntity implements IRoom {
  id?: number;
  name?: string | undefined;
  shortName?: string | undefined;
  chineseName?: string | undefined;
  mappingKey?: string | undefined;
  roomSettings?: RoomSettings | undefined;
  roomSettingsId?: number;
  combinableRooms?: number[] | undefined;
  roomSets?: RoomSet[] | undefined;
  roomExtraInfoFields?: RoomExtraInfoField[] | undefined;
  roomExtraProperties?: RoomExtraProperty[] | undefined;

  constructor(data?: IRoom) {
    super(data);
  }

  init(_data?: any) {
    super.init(_data);
    if (_data) {
      this.id = _data["id"];
      this.name = _data["name"];
      this.shortName = _data["shortName"];
      this.chineseName = _data["chineseName"];
      this.mappingKey = _data["mappingKey"];
      this.roomSettings = _data["roomSettings"]
        ? RoomSettings.fromJS(_data["roomSettings"])
        : <any>undefined;
      this.roomSettingsId = _data["roomSettingsId"];
      if (Array.isArray(_data["combinableRooms"])) {
        this.combinableRooms = [] as any;
        for (let item of _data["combinableRooms"])
          this.combinableRooms!.push(item);
      }
      if (Array.isArray(_data["roomSets"])) {
        this.roomSets = [] as any;
        for (let item of _data["roomSets"])
          this.roomSets!.push(RoomSet.fromJS(item));
      }
      if (Array.isArray(_data["roomExtraInfoFields"])) {
        this.roomExtraInfoFields = [] as any;
        for (let item of _data["roomExtraInfoFields"])
          this.roomExtraInfoFields!.push(RoomExtraInfoField.fromJS(item));
      }
      if (Array.isArray(_data["roomExtraProperties"])) {
        this.roomExtraProperties = [] as any;
        for (let item of _data["roomExtraProperties"])
          this.roomExtraProperties!.push(RoomExtraProperty.fromJS(item));
      }
    }
  }

  static fromJS(data: any): Room {
    data = typeof data === "object" ? data : {};
    let result = new Room();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["name"] = this.name;
    data["shortName"] = this.shortName;
    data["chineseName"] = this.chineseName;
    data["mappingKey"] = this.mappingKey;
    data["roomSettings"] = this.roomSettings
      ? this.roomSettings.toJSON()
      : <any>undefined;
    data["roomSettingsId"] = this.roomSettingsId;
    if (Array.isArray(this.combinableRooms)) {
      data["combinableRooms"] = [];
      for (let item of this.combinableRooms) data["combinableRooms"].push(item);
    }
    if (Array.isArray(this.roomSets)) {
      data["roomSets"] = [];
      for (let item of this.roomSets) data["roomSets"].push(item.toJSON());
    }
    if (Array.isArray(this.roomExtraInfoFields)) {
      data["roomExtraInfoFields"] = [];
      for (let item of this.roomExtraInfoFields)
        data["roomExtraInfoFields"].push(item.toJSON());
    }
    if (Array.isArray(this.roomExtraProperties)) {
      data["roomExtraProperties"] = [];
      for (let item of this.roomExtraProperties)
        data["roomExtraProperties"].push(item.toJSON());
    }
    super.toJSON(data);
    return data;
  }
}

export interface IRoom extends IAuditableEntity {
  id?: number;
  name?: string | undefined;
  shortName?: string | undefined;
  chineseName?: string | undefined;
  mappingKey?: string | undefined;
  roomSettings?: RoomSettings | undefined;
  roomSettingsId?: number;
  combinableRooms?: number[] | undefined;
  roomSets?: RoomSet[] | undefined;
  roomExtraInfoFields?: RoomExtraInfoField[] | undefined;
  roomExtraProperties?: RoomExtraProperty[] | undefined;
}

export class RoomSettings implements IRoomSettings {
  id?: number;
  bookingPeriods?: RoomTimeslot[] | undefined;
  bookingUserMode?: BookingUserMode;
  autoRelease?: number;
  disabled?: boolean;
  defaultBookingType?: BookingType;
  inAdvanceDay?: number;

  constructor(data?: IRoomSettings) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      if (Array.isArray(_data["bookingPeriods"])) {
        this.bookingPeriods = [] as any;
        for (let item of _data["bookingPeriods"])
          this.bookingPeriods!.push(RoomTimeslot.fromJS(item));
      }
      this.bookingUserMode = _data["bookingUserMode"];
      this.autoRelease = _data["autoRelease"];
      this.disabled = _data["disabled"];
      this.defaultBookingType = _data["defaultBookingType"];
      this.inAdvanceDay = _data["inAdvanceDay"];
    }
  }

  static fromJS(data: any): RoomSettings {
    data = typeof data === "object" ? data : {};
    let result = new RoomSettings();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    if (Array.isArray(this.bookingPeriods)) {
      data["bookingPeriods"] = [];
      for (let item of this.bookingPeriods)
        data["bookingPeriods"].push(item.toJSON());
    }
    data["bookingUserMode"] = this.bookingUserMode;
    data["autoRelease"] = this.autoRelease;
    data["disabled"] = this.disabled;
    data["defaultBookingType"] = this.defaultBookingType;
    data["inAdvanceDay"] = this.inAdvanceDay;
    return data;
  }
}

export interface IRoomSettings {
  id?: number;
  bookingPeriods?: RoomTimeslot[] | undefined;
  bookingUserMode?: BookingUserMode;
  autoRelease?: number;
  disabled?: boolean;
  defaultBookingType?: BookingType;
  inAdvanceDay?: number;
}

export class RoomTimeslot implements IRoomTimeslot {
  id?: number;
  dayOfWeek?: DayOfWeek;
  startTime?: Date;
  endTime?: Date;
  interval?: string;

  constructor(data?: IRoomTimeslot) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.dayOfWeek = _data["dayOfWeek"];
      this.startTime = _data["startTime"]
        ? new Date(_data["startTime"].toString())
        : <any>undefined;
      this.endTime = _data["endTime"]
        ? new Date(_data["endTime"].toString())
        : <any>undefined;
      this.interval = _data["interval"];
    }
  }

  static fromJS(data: any): RoomTimeslot {
    data = typeof data === "object" ? data : {};
    let result = new RoomTimeslot();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["dayOfWeek"] = this.dayOfWeek;
    data["startTime"] = this.startTime
      ? this.startTime.toISOString()
      : <any>undefined;
    data["endTime"] = this.endTime
      ? this.endTime.toISOString()
      : <any>undefined;
    data["interval"] = this.interval;
    return data;
  }
}

export interface IRoomTimeslot {
  id?: number;
  dayOfWeek?: DayOfWeek;
  startTime?: Date;
  endTime?: Date;
  interval?: string;
}

export enum DayOfWeek {
  Sunday = 0,
  Monday = 1,
  Tuesday = 2,
  Wednesday = 3,
  Thursday = 4,
  Friday = 5,
  Saturday = 6,
}

export enum BookingUserMode {
  Anyone = 0,
  Admin = 1,
}

export class RoomSet extends AuditableEntity implements IRoomSet {
  id?: number;
  name?: string | undefined;
  allRooms?: boolean;
  isChecked?: boolean;
  softwareSystem?: boolean;
  rooms?: Room[] | undefined;

  constructor(data?: IRoomSet) {
    super(data);
  }

  init(_data?: any) {
    super.init(_data);
    if (_data) {
      this.id = _data["id"];
      this.name = _data["name"];
      this.allRooms = _data["allRooms"];
      this.softwareSystem = _data["softwareSystem"];
      if (Array.isArray(_data["rooms"])) {
        this.rooms = [] as any;
        for (let item of _data["rooms"]) this.rooms!.push(Room.fromJS(item));
      }
    }
  }

  static fromJS(data: any): RoomSet {
    data = typeof data === "object" ? data : {};
    let result = new RoomSet();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["name"] = this.name;
    data["allRooms"] = this.allRooms;
    data["softwareSystem"] = this.softwareSystem;
    if (Array.isArray(this.rooms)) {
      data["rooms"] = [];
      for (let item of this.rooms) data["rooms"].push(item.toJSON());
    }
    super.toJSON(data);
    return data;
  }
}

export interface IRoomSet extends IAuditableEntity {
  id?: number;
  name?: string | undefined;
  allRooms?: boolean;
  softwareSystem?: boolean;
  rooms?: Room[] | undefined;
}

export class RoomExtraInfoField implements IRoomExtraInfoField {
  id?: number;
  key?: string | undefined;
  value?: string | undefined;

  constructor(data?: IRoomExtraInfoField) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.key = _data["key"];
      this.value = _data["value"];
    }
  }

  static fromJS(data: any): RoomExtraInfoField {
    data = typeof data === "object" ? data : {};
    let result = new RoomExtraInfoField();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["key"] = this.key;
    data["value"] = this.value;
    return data;
  }
}

export interface IRoomExtraInfoField {
  id?: number;
  key?: string | undefined;
  value?: string | undefined;
}

export class RoomExtraProperty implements IRoomExtraProperty {
  id?: number;
  keyId?: number;
  valueId?: number;

  constructor(data?: IRoomExtraProperty) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.keyId = _data["keyId"];
      this.valueId = _data["valueId"];
    }
  }

  static fromJS(data: any): RoomExtraProperty {
    data = typeof data === "object" ? data : {};
    let result = new RoomExtraProperty();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["keyId"] = this.keyId;
    data["valueId"] = this.valueId;
    return data;
  }
}

export interface IRoomExtraProperty {
  id?: number;
  keyId?: number;
  valueId?: number;
}

export class BookingApplicationUser implements IBookingApplicationUser {
  applicationUserId?: string | undefined;
  bookingId?: number;

  constructor(data?: IBookingApplicationUser) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.applicationUserId = _data["applicationUserId"];
      this.bookingId = _data["bookingId"];
    }
  }

  static fromJS(data: any): BookingApplicationUser {
    data = typeof data === "object" ? data : {};
    let result = new BookingApplicationUser();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["applicationUserId"] = this.applicationUserId;
    data["bookingId"] = this.bookingId;
    return data;
  }
}

export interface IBookingApplicationUser {
  applicationUserId?: string | undefined;
  bookingId?: number;
}

export class CancelCommand implements ICancelCommand {
  bookingId?: number;
  reason?: string | undefined;

  constructor(data?: ICancelCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.bookingId = _data["bookingId"];
      this.reason = _data["reason"];
    }
  }

  static fromJS(data: any): CancelCommand {
    data = typeof data === "object" ? data : {};
    let result = new CancelCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["bookingId"] = this.bookingId;
    data["reason"] = this.reason;
    return data;
  }
}

export interface ICancelCommand {
  bookingId?: number;
  reason?: string | undefined;
}

export class UpdateSimpleBookingCommand implements IUpdateSimpleBookingCommand {
  bookingId?: number;
  roomId?: number;
  newRoomId?: number;
  name?: string | undefined;
  names?: string[] | undefined;
  bookingDetailDto?: BookingDetailDto | undefined;
  date?: Date;
  startTime?: Date;
  endTime?: Date;
  bookingType?: BookingType;

  constructor(data?: IUpdateSimpleBookingCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.bookingId = _data["bookingId"];
      this.roomId = _data["roomId"];
      this.newRoomId = _data["newRoomId"];
      this.name = _data["name"];
      if (Array.isArray(_data["names"])) {
        this.names = [] as any;
        for (let item of _data["names"]) this.names!.push(item);
      }
      this.bookingDetailDto = _data["bookingDetailDto"]
        ? BookingDetailDto.fromJS(_data["bookingDetailDto"])
        : <any>undefined;
      this.date = _data["date"]
        ? new Date(_data["date"].toString())
        : <any>undefined;
      this.startTime = _data["startTime"]
        ? new Date(_data["startTime"].toString())
        : <any>undefined;
      this.endTime = _data["endTime"]
        ? new Date(_data["endTime"].toString())
        : <any>undefined;
      this.bookingType = _data["bookingType"];
    }
  }

  static fromJS(data: any): UpdateSimpleBookingCommand {
    data = typeof data === "object" ? data : {};
    let result = new UpdateSimpleBookingCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["bookingId"] = this.bookingId;
    data["roomId"] = this.roomId;
    data["newRoomId"] = this.newRoomId;
    data["name"] = this.name;
    if (Array.isArray(this.names)) {
      data["names"] = [];
      for (let item of this.names) data["names"].push(item);
    }
    data["bookingDetailDto"] = this.bookingDetailDto
      ? this.bookingDetailDto.toJSON()
      : <any>undefined;
    data["date"] = this.date ? this.date.toISOString() : <any>undefined;
    data["startTime"] = this.startTime
      ? this.startTime.toISOString()
      : <any>undefined;
    data["endTime"] = this.endTime
      ? this.endTime.toISOString()
      : <any>undefined;
    data["bookingType"] = this.bookingType;
    return data;
  }
}

export interface IUpdateSimpleBookingCommand {
  bookingId?: number;
  roomId?: number;
  newRoomId?: number;
  name?: string | undefined;
  names?: string[] | undefined;
  bookingDetailDto?: BookingDetailDto | undefined;
  date?: Date;
  startTime?: Date;
  endTime?: Date;
  bookingType?: BookingType;
}

export class GetMarkedAsClosedCommand implements IGetMarkedAsClosedCommand {
  from?: Date | undefined;
  to?: Date | undefined;

  constructor(data?: IGetMarkedAsClosedCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.from = _data["from"]
        ? new Date(_data["from"].toString())
        : <any>undefined;
      this.to = _data["to"] ? new Date(_data["to"].toString()) : <any>undefined;
    }
  }

  static fromJS(data: any): GetMarkedAsClosedCommand {
    data = typeof data === "object" ? data : {};
    let result = new GetMarkedAsClosedCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["from"] = this.from ? this.from.toISOString() : <any>undefined;
    data["to"] = this.to ? this.to.toISOString() : <any>undefined;
    return data;
  }
}

export interface IGetMarkedAsClosedCommand {
  from?: Date | undefined;
  to?: Date | undefined;
}

export class EquipmentNameDtos implements IEquipmentNameDtos {
  name?: string | undefined;
  equipmentCode?: string | undefined;
  departmentCode?: string | undefined;

  constructor(data?: IEquipmentNameDtos) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data["name"];
      this.equipmentCode = _data["equipmentCode"];
      this.departmentCode = _data["departmentCode"];
    }
  }

  static fromJS(data: any): EquipmentNameDtos {
    data = typeof data === "object" ? data : {};
    let result = new EquipmentNameDtos();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["name"] = this.name;
    data["equipmentCode"] = this.equipmentCode;
    data["departmentCode"] = this.departmentCode;
    return data;
  }
}

export interface IEquipmentNameDtos {
  name?: string | undefined;
  equipmentCode?: string | undefined;
  departmentCode?: string | undefined;
}

export class CreateEquipmentCommand implements ICreateEquipmentCommand {
  name?: string | undefined;
  departmentCode?: string | undefined;

  constructor(data?: ICreateEquipmentCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data["name"];
      this.departmentCode = _data["departmentCode"];
    }
  }

  static fromJS(data: any): CreateEquipmentCommand {
    data = typeof data === "object" ? data : {};
    let result = new CreateEquipmentCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["name"] = this.name;
    data["departmentCode"] = this.departmentCode;
    return data;
  }
}

export interface ICreateEquipmentCommand {
  name?: string | undefined;
  departmentCode?: string | undefined;
}

export class DeleteEquipmentCommand implements IDeleteEquipmentCommand {
  equipmentCode?: string | undefined;

  constructor(data?: IDeleteEquipmentCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.equipmentCode = _data["equipmentCode"];
    }
  }

  static fromJS(data: any): DeleteEquipmentCommand {
    data = typeof data === "object" ? data : {};
    let result = new DeleteEquipmentCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["equipmentCode"] = this.equipmentCode;
    return data;
  }
}

export interface IDeleteEquipmentCommand {
  equipmentCode?: string | undefined;
}

export class UpdateEquipmentCommand implements IUpdateEquipmentCommand {
  equipmentCode?: string | undefined;
  name?: string | undefined;
  departmentCode?: string | undefined;

  constructor(data?: IUpdateEquipmentCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.equipmentCode = _data["equipmentCode"];
      this.name = _data["name"];
      this.departmentCode = _data["departmentCode"];
    }
  }

  static fromJS(data: any): UpdateEquipmentCommand {
    data = typeof data === "object" ? data : {};
    let result = new UpdateEquipmentCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["equipmentCode"] = this.equipmentCode;
    data["name"] = this.name;
    data["departmentCode"] = this.departmentCode;
    return data;
  }
}

export interface IUpdateEquipmentCommand {
  equipmentCode?: string | undefined;
  name?: string | undefined;
  departmentCode?: string | undefined;
}

export class RoomNameListDto implements IRoomNameListDto {
  roomExtraInfoFields?: RoomExtraInfoField[] | undefined;
  id?: number;
  idCode?: string | undefined;
  name?: string | undefined;
  shortName?: string | undefined;
  chineseName?: string | undefined;
  mappingKey?: string | undefined;
  start?: Date;
  end?: Date;
  isChecked?: false;

  constructor(data?: IRoomNameListDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["roomExtraInfoFields"])) {
        this.roomExtraInfoFields = [] as any;
        for (let item of _data["roomExtraInfoFields"])
          this.roomExtraInfoFields!.push(RoomExtraInfoField.fromJS(item));
      }
      this.id = _data["id"];
      this.idCode = _data["idCode"];
      this.name = _data["name"];
      this.shortName = _data["shortName"];
      this.chineseName = _data["chineseName"];
      this.mappingKey = _data["mappingKey"];
      this.start = _data["start"]
        ? new Date(_data["start"].toString())
        : <any>undefined;
      this.end = _data["end"]
        ? new Date(_data["end"].toString())
        : <any>undefined;
    }
  }

  static fromJS(data: any): RoomNameListDto {
    data = typeof data === "object" ? data : {};
    let result = new RoomNameListDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.roomExtraInfoFields)) {
      data["roomExtraInfoFields"] = [];
      for (let item of this.roomExtraInfoFields)
        data["roomExtraInfoFields"].push(item.toJSON());
    }
    data["id"] = this.id;
    data["idCode"] = this.idCode;
    data["name"] = this.name;
    data["shortName"] = this.shortName;
    data["chineseName"] = this.chineseName;
    data["mappingKey"] = this.mappingKey;
    data["start"] = this.start ? this.start.toISOString() : <any>undefined;
    data["end"] = this.end ? this.end.toISOString() : <any>undefined;
    return data;
  }
}

export interface IRoomNameListDto {
  roomExtraInfoFields?: RoomExtraInfoField[] | undefined;
  id?: number;
  idCode?: string | undefined;
  name?: string | undefined;
  shortName?: string | undefined;
  chineseName?: string | undefined;
  mappingKey?: string | undefined;
  start?: Date;
  end?: Date;
}

export class CreateUpdateRoomDto
  extends AuditableEntity
  implements ICreateUpdateRoomDto
{
  roomId?: number;
  name?: string | undefined;
  shortName?: string | undefined;
  chineseName?: string | undefined;
  mappingKey?: string | undefined;
  start?: Date;
  end?: Date;
  timeSpanMinutes?: number;
  bookingUserModeId?: number;
  autoRelease?: number;
  disabled?: boolean;
  defaultBookingTypeId?: number;
  inAdvanceDay?: number;
  roomExtraInfoFields?: RoomExtraInfoField[] | undefined;

  constructor(data?: ICreateUpdateRoomDto) {
    super(data);
  }

  init(_data?: any) {
    super.init(_data);
    if (_data) {
      this.roomId = _data["roomId"];
      this.name = _data["name"];
      this.shortName = _data["shortName"];
      this.chineseName = _data["chineseName"];
      this.mappingKey = _data["mappingKey"];
      this.start = _data["start"]
        ? new Date(_data["start"].toString())
        : <any>undefined;
      this.end = _data["end"]
        ? new Date(_data["end"].toString())
        : <any>undefined;
      this.timeSpanMinutes = _data["timeSpanMinutes"];
      this.bookingUserModeId = _data["bookingUserModeId"];
      this.autoRelease = _data["autoRelease"];
      this.disabled = _data["disabled"];
      this.defaultBookingTypeId = _data["defaultBookingTypeId"];
      this.inAdvanceDay = _data["inAdvanceDay"];
      if (Array.isArray(_data["roomExtraInfoFields"])) {
        this.roomExtraInfoFields = [] as any;
        for (let item of _data["roomExtraInfoFields"])
          this.roomExtraInfoFields!.push(RoomExtraInfoField.fromJS(item));
      }
    }
  }

  static fromJS(data: any): CreateUpdateRoomDto {
    data = typeof data === "object" ? data : {};
    let result = new CreateUpdateRoomDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["roomId"] = this.roomId;
    data["name"] = this.name;
    data["shortName"] = this.shortName;
    data["chineseName"] = this.chineseName;
    data["mappingKey"] = this.mappingKey;
    data["start"] = this.start ? this.start.toISOString() : <any>undefined;
    data["end"] = this.end ? this.end.toISOString() : <any>undefined;
    data["timeSpanMinutes"] = this.timeSpanMinutes;
    data["bookingUserModeId"] = this.bookingUserModeId;
    data["autoRelease"] = this.autoRelease;
    data["disabled"] = this.disabled;
    data["defaultBookingTypeId"] = this.defaultBookingTypeId;
    data["inAdvanceDay"] = this.inAdvanceDay;
    if (Array.isArray(this.roomExtraInfoFields)) {
      data["roomExtraInfoFields"] = [];
      for (let item of this.roomExtraInfoFields)
        data["roomExtraInfoFields"].push(item.toJSON());
    }
    super.toJSON(data);
    return data;
  }
}

export interface ICreateUpdateRoomDto extends IAuditableEntity {
  roomId?: number;
  name?: string | undefined;
  shortName?: string | undefined;
  chineseName?: string | undefined;
  mappingKey?: string | undefined;
  start?: Date;
  end?: Date;
  timeSpanMinutes?: number;
  bookingUserModeId?: number;
  autoRelease?: number;
  disabled?: boolean;
  defaultBookingTypeId?: number;
  inAdvanceDay?: number;
  roomExtraInfoFields?: RoomExtraInfoField[] | undefined;
}

export class CreateRoomCommand
  extends CreateUpdateRoomDto
  implements ICreateRoomCommand
{
  constructor(data?: ICreateRoomCommand) {
    super(data);
  }

  init(_data?: any) {
    super.init(_data);
  }

  static fromJS(data: any): CreateRoomCommand {
    data = typeof data === "object" ? data : {};
    let result = new CreateRoomCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    super.toJSON(data);
    return data;
  }
}

export interface ICreateRoomCommand extends ICreateUpdateRoomDto {}

export class Unit implements IUnit {
  constructor(data?: IUnit) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {}

  static fromJS(data: any): Unit {
    data = typeof data === "object" ? data : {};
    let result = new Unit();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    return data;
  }
}

export interface IUnit {}

export class UpdateRoomCommand
  extends CreateUpdateRoomDto
  implements IUpdateRoomCommand
{
  constructor(data?: IUpdateRoomCommand) {
    super(data);
  }

  init(_data?: any) {
    super.init(_data);
  }

  static fromJS(data: any): UpdateRoomCommand {
    data = typeof data === "object" ? data : {};
    let result = new UpdateRoomCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    super.toJSON(data);
    return data;
  }
}

export interface IUpdateRoomCommand extends ICreateUpdateRoomDto {}

export class CreateRoomSetCommand implements ICreateRoomSetCommand {
  name?: string | undefined;
  allRoom?: boolean;
  roomIds?: number[] | undefined;

  constructor(data?: ICreateRoomSetCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data["name"];
      this.allRoom = _data["allRoom"];
      if (Array.isArray(_data["roomIds"])) {
        this.roomIds = [] as any;
        for (let item of _data["roomIds"]) this.roomIds!.push(item);
      }
    }
  }

  static fromJS(data: any): CreateRoomSetCommand {
    data = typeof data === "object" ? data : {};
    let result = new CreateRoomSetCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["name"] = this.name;
    data["allRoom"] = this.allRoom;
    if (Array.isArray(this.roomIds)) {
      data["roomIds"] = [];
      for (let item of this.roomIds) data["roomIds"].push(item);
    }
    return data;
  }
}

export interface ICreateRoomSetCommand {
  name?: string | undefined;
  allRoom?: boolean;
  roomIds?: number[] | undefined;
}

export class UpdateRoomSetCommand implements IUpdateRoomSetCommand {
  name?: string | undefined;
  id?: number;
  allRoom?: boolean;
  roomIds?: number[] | undefined;

  constructor(data?: IUpdateRoomSetCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data["name"];
      this.id = _data["id"];
      this.allRoom = _data["allRoom"];
      if (Array.isArray(_data["roomIds"])) {
        this.roomIds = [] as any;
        for (let item of _data["roomIds"]) this.roomIds!.push(item);
      }
    }
  }

  static fromJS(data: any): UpdateRoomSetCommand {
    data = typeof data === "object" ? data : {};
    let result = new UpdateRoomSetCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["name"] = this.name;
    data["id"] = this.id;
    data["allRoom"] = this.allRoom;
    if (Array.isArray(this.roomIds)) {
      data["roomIds"] = [];
      for (let item of this.roomIds) data["roomIds"].push(item);
    }
    return data;
  }
}

export interface IUpdateRoomSetCommand {
  name?: string | undefined;
  id?: number;
  allRoom?: boolean;
  roomIds?: number[] | undefined;
}

export class DeleteRoomSetCommand implements IDeleteRoomSetCommand {
  id?: number;

  constructor(data?: IDeleteRoomSetCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): DeleteRoomSetCommand {
    data = typeof data === "object" ? data : {};
    let result = new DeleteRoomSetCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    return data;
  }
}

export interface IDeleteRoomSetCommand {
  id?: number;
}

export class GetAllRoomSets implements IGetAllRoomSets {
  constructor(data?: IGetAllRoomSets) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {}

  static fromJS(data: any): GetAllRoomSets {
    data = typeof data === "object" ? data : {};
    let result = new GetAllRoomSets();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    return data;
  }
}

export interface IGetAllRoomSets {}

export class RoomSetDto extends AuditableEntity implements IRoomSetDto {
  roomIds?: number[] | undefined;
  id?: number;
  name?: string | undefined;
  allRoom?: boolean;

  constructor(data?: IRoomSetDto) {
    super(data);
  }

  init(_data?: any) {
    super.init(_data);
    if (_data) {
      if (Array.isArray(_data["roomIds"])) {
        this.roomIds = [] as any;
        for (let item of _data["roomIds"]) this.roomIds!.push(item);
      }
      this.id = _data["id"];
      this.name = _data["name"];
      this.allRoom = _data["allRoom"];
    }
  }

  static fromJS(data: any): RoomSetDto {
    data = typeof data === "object" ? data : {};
    let result = new RoomSetDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.roomIds)) {
      data["roomIds"] = [];
      for (let item of this.roomIds) data["roomIds"].push(item);
    }
    data["id"] = this.id;
    data["name"] = this.name;
    data["allRoom"] = this.allRoom;
    super.toJSON(data);
    return data;
  }
}

export interface IRoomSetDto extends IAuditableEntity {
  roomIds?: number[] | undefined;
  id?: number;
  name?: string | undefined;
  allRoom?: boolean;
}

export class RoomSetSimpleDto implements IRoomSetSimpleDto {
  id?: number;
  name?: string | undefined;

  constructor(data?: IRoomSetSimpleDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.name = _data["name"];
    }
  }

  static fromJS(data: any): RoomSetSimpleDto {
    data = typeof data === "object" ? data : {};
    let result = new RoomSetSimpleDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["name"] = this.name;
    return data;
  }
}

export interface IRoomSetSimpleDto {
  id?: number;
  name?: string | undefined;
}

export class RoomExtraInfoTemplate implements IRoomExtraInfoTemplate {
  id?: number;
  key?: string | undefined;
  type?: FieldType;

  constructor(data?: IRoomExtraInfoTemplate) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.key = _data["key"];
      this.type = _data["type"];
    }
  }

  static fromJS(data: any): RoomExtraInfoTemplate {
    data = typeof data === "object" ? data : {};
    let result = new RoomExtraInfoTemplate();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["key"] = this.key;
    data["type"] = this.type;
    return data;
  }
}

export interface IRoomExtraInfoTemplate {
  id?: number;
  key?: string | undefined;
  type?: FieldType;
}

export enum FieldType {
  String = 1,
  Number = 2,
}

export class UpdateRoomExtraFieldsCommand
  implements IUpdateRoomExtraFieldsCommand
{
  roomExtraInfoTemplate?: RoomExtraInfoTemplate[] | undefined;

  constructor(data?: IUpdateRoomExtraFieldsCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["roomExtraInfoTemplate"])) {
        this.roomExtraInfoTemplate = [] as any;
        for (let item of _data["roomExtraInfoTemplate"])
          this.roomExtraInfoTemplate!.push(RoomExtraInfoTemplate.fromJS(item));
      }
    }
  }

  static fromJS(data: any): UpdateRoomExtraFieldsCommand {
    data = typeof data === "object" ? data : {};
    let result = new UpdateRoomExtraFieldsCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.roomExtraInfoTemplate)) {
      data["roomExtraInfoTemplate"] = [];
      for (let item of this.roomExtraInfoTemplate)
        data["roomExtraInfoTemplate"].push(item.toJSON());
    }
    return data;
  }
}

export interface IUpdateRoomExtraFieldsCommand {
  roomExtraInfoTemplate?: RoomExtraInfoTemplate[] | undefined;
}

export class BookingEvent implements IBookingEvent {
  title?: string | undefined;
  start?: string | undefined;
  end?: string | undefined;
  id?: number;
  resourceid?: number;

  constructor(data?: IBookingEvent) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.title = _data["title"];
      this.start = _data["start"];
      this.end = _data["end"];
      this.id = _data["id"];
      this.resourceid = _data["resourceid"];
    }
  }

  static fromJS(data: any): BookingEvent {
    data = typeof data === "object" ? data : {};
    let result = new BookingEvent();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["title"] = this.title;
    data["start"] = this.start;
    data["end"] = this.end;
    data["id"] = this.id;
    data["resourceid"] = this.resourceid;
    return data;
  }
}

export interface IBookingEvent {
  title?: string | undefined;
  start?: string | undefined;
  end?: string | undefined;
  id?: number;
  resourceid?: number;
}

export class SendResponse implements ISendResponse {
  messageId?: string | undefined;
  errorMessages?: string[] | undefined;
  successful?: boolean;

  constructor(data?: ISendResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.messageId = _data["messageId"];
      if (Array.isArray(_data["errorMessages"])) {
        this.errorMessages = [] as any;
        for (let item of _data["errorMessages"]) this.errorMessages!.push(item);
      }
      this.successful = _data["successful"];
    }
  }

  static fromJS(data: any): SendResponse {
    data = typeof data === "object" ? data : {};
    let result = new SendResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["messageId"] = this.messageId;
    if (Array.isArray(this.errorMessages)) {
      data["errorMessages"] = [];
      for (let item of this.errorMessages) data["errorMessages"].push(item);
    }
    data["successful"] = this.successful;
    return data;
  }
}

export interface ISendResponse {
  messageId?: string | undefined;
  errorMessages?: string[] | undefined;
  successful?: boolean;
}

export class SendTestMailCommand implements ISendTestMailCommand {
  subject?: string | undefined;
  body?: string | undefined;

  constructor(data?: ISendTestMailCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.subject = _data["subject"];
      this.body = _data["body"];
    }
  }

  static fromJS(data: any): SendTestMailCommand {
    data = typeof data === "object" ? data : {};
    let result = new SendTestMailCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["subject"] = this.subject;
    data["body"] = this.body;
    return data;
  }
}

export interface ISendTestMailCommand {
  subject?: string | undefined;
  body?: string | undefined;
}

export class SimpleServiceDto implements ISimpleServiceDto {
  name?: string | undefined;
  value?: number;

  constructor(data?: ISimpleServiceDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data["name"];
      this.value = _data["value"];
    }
  }

  static fromJS(data: any): SimpleServiceDto {
    data = typeof data === "object" ? data : {};
    let result = new SimpleServiceDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["name"] = this.name;
    data["value"] = this.value;
    return data;
  }
}

export interface ISimpleServiceDto {
  name?: string | undefined;
  value?: number;
}

export class UpdateEmailSettingsCommand implements IUpdateEmailSettingsCommand {
  settings?: SmtpClientOptions | undefined;

  constructor(data?: IUpdateEmailSettingsCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.settings = _data["settings"]
        ? SmtpClientOptions.fromJS(_data["settings"])
        : <any>undefined;
    }
  }

  static fromJS(data: any): UpdateEmailSettingsCommand {
    data = typeof data === "object" ? data : {};
    let result = new UpdateEmailSettingsCommand();
    result.init(data);
    return result;
  }

  // toJSON(data?: any) {
  //   data = typeof data === "object" ? data : {};
  //   data["settings"] = this.settings ? this.settings.toJSON() : <any>undefined;
  //   return data;
  // }
}

export interface IUpdateEmailSettingsCommand {
  settings?: SmtpClientOptions | undefined;
}

export class SmtpClientOptions implements ISmtpClientOptions {
  server?: string | undefined;
  port?: number;
  user?: string | undefined;
  password?: string | undefined;
  useSsl?: boolean;
  requiresAuthentication?: boolean;
  preferredEncoding?: string | undefined;
  usePickupDirectory?: boolean;
  mailPickupDirectory?: string | undefined;
  socketOptions?: SecureSocketOptions | undefined;

  constructor(data?: ISmtpClientOptions) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.server = _data["server"];
      this.port = _data["port"];
      this.user = _data["user"];
      this.password = _data["password"];
      this.useSsl = _data["useSsl"];
      this.requiresAuthentication = _data["requiresAuthentication"];
      this.preferredEncoding = _data["preferredEncoding"];
      this.usePickupDirectory = _data["usePickupDirectory"];
      this.mailPickupDirectory = _data["mailPickupDirectory"];
      this.socketOptions = _data["socketOptions"];
    }
  }

  static fromJS(data: any): SmtpClientOptions {
    data = typeof data === "object" ? data : {};
    let result = new SmtpClientOptions();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["server"] = this.server;
    data["port"] = this.port;
    data["user"] = this.user;
    data["password"] = this.password;
    data["useSsl"] = this.useSsl;
    data["requiresAuthentication"] = this.requiresAuthentication;
    data["preferredEncoding"] = this.preferredEncoding;
    data["usePickupDirectory"] = this.usePickupDirectory;
    data["mailPickupDirectory"] = this.mailPickupDirectory;
    data["socketOptions"] = this.socketOptions;
    return data;
  }
}

export interface ISmtpClientOptions {
  server?: string | undefined;
  port?: number;
  user?: string | undefined;
  password?: string | undefined;
  useSsl?: boolean;
  requiresAuthentication?: boolean;
  preferredEncoding?: string | undefined;
  usePickupDirectory?: boolean;
  mailPickupDirectory?: string | undefined;
  socketOptions?: SecureSocketOptions | undefined;
}

export enum SecureSocketOptions {
  None = 0,
  Auto = 1,
  SslOnConnect = 2,
  StartTls = 3,
  StartTlsWhenAvailable = 4,
}

export class PaginatedListOfTodoItemDto implements IPaginatedListOfTodoItemDto {
  items?: TodoItemDto[] | undefined;
  pageIndex?: number;
  totalPages?: number;
  totalCount?: number;
  hasPreviousPage?: boolean;
  hasNextPage?: boolean;

  constructor(data?: IPaginatedListOfTodoItemDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["items"])) {
        this.items = [] as any;
        for (let item of _data["items"])
          this.items!.push(TodoItemDto.fromJS(item));
      }
      this.pageIndex = _data["pageIndex"];
      this.totalPages = _data["totalPages"];
      this.totalCount = _data["totalCount"];
      this.hasPreviousPage = _data["hasPreviousPage"];
      this.hasNextPage = _data["hasNextPage"];
    }
  }

  static fromJS(data: any): PaginatedListOfTodoItemDto {
    data = typeof data === "object" ? data : {};
    let result = new PaginatedListOfTodoItemDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.items)) {
      data["items"] = [];
      for (let item of this.items) data["items"].push(item.toJSON());
    }
    data["pageIndex"] = this.pageIndex;
    data["totalPages"] = this.totalPages;
    data["totalCount"] = this.totalCount;
    data["hasPreviousPage"] = this.hasPreviousPage;
    data["hasNextPage"] = this.hasNextPage;
    return data;
  }
}

export interface IPaginatedListOfTodoItemDto {
  items?: TodoItemDto[] | undefined;
  pageIndex?: number;
  totalPages?: number;
  totalCount?: number;
  hasPreviousPage?: boolean;
  hasNextPage?: boolean;
}

export class TodoItemDto implements ITodoItemDto {
  id?: number;
  listId?: number;
  title?: string | undefined;
  done?: boolean;
  priority?: number;
  note?: string | undefined;

  constructor(data?: ITodoItemDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.listId = _data["listId"];
      this.title = _data["title"];
      this.done = _data["done"];
      this.priority = _data["priority"];
      this.note = _data["note"];
    }
  }

  static fromJS(data: any): TodoItemDto {
    data = typeof data === "object" ? data : {};
    let result = new TodoItemDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["listId"] = this.listId;
    data["title"] = this.title;
    data["done"] = this.done;
    data["priority"] = this.priority;
    data["note"] = this.note;
    return data;
  }
}

export interface ITodoItemDto {
  id?: number;
  listId?: number;
  title?: string | undefined;
  done?: boolean;
  priority?: number;
  note?: string | undefined;
}

export class CreateTodoItemCommand implements ICreateTodoItemCommand {
  listId?: number;
  bookingId?: number;
  title?: string | undefined;

  constructor(data?: ICreateTodoItemCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.listId = _data["listId"];
      this.bookingId = _data["bookingId"];
      this.title = _data["title"];
    }
  }

  static fromJS(data: any): CreateTodoItemCommand {
    data = typeof data === "object" ? data : {};
    let result = new CreateTodoItemCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["listId"] = this.listId;
    data["bookingId"] = this.bookingId;
    data["title"] = this.title;
    return data;
  }
}

export interface ICreateTodoItemCommand {
  listId?: number;
  bookingId?: number;
  title?: string | undefined;
}

export class UpdateTodoItemCommand implements IUpdateTodoItemCommand {
  id?: number;
  title?: string | undefined;
  done?: boolean;

  constructor(data?: IUpdateTodoItemCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.title = _data["title"];
      this.done = _data["done"];
    }
  }

  static fromJS(data: any): UpdateTodoItemCommand {
    data = typeof data === "object" ? data : {};
    let result = new UpdateTodoItemCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["title"] = this.title;
    data["done"] = this.done;
    return data;
  }
}

export interface IUpdateTodoItemCommand {
  id?: number;
  title?: string | undefined;
  done?: boolean;
}

export class UpdateTodoItemDetailCommand
  implements IUpdateTodoItemDetailCommand
{
  id?: number;
  listId?: number;
  priority?: PriorityLevel;
  note?: string | undefined;

  constructor(data?: IUpdateTodoItemDetailCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.listId = _data["listId"];
      this.priority = _data["priority"];
      this.note = _data["note"];
    }
  }

  static fromJS(data: any): UpdateTodoItemDetailCommand {
    data = typeof data === "object" ? data : {};
    let result = new UpdateTodoItemDetailCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["listId"] = this.listId;
    data["priority"] = this.priority;
    data["note"] = this.note;
    return data;
  }
}

export interface IUpdateTodoItemDetailCommand {
  id?: number;
  listId?: number;
  priority?: PriorityLevel;
  note?: string | undefined;
}

export enum PriorityLevel {
  None = 0,
  Low = 1,
  Medium = 2,
  High = 3,
}

export class TodosVm implements ITodosVm {
  priorityLevels?: PriorityLevelDto[] | undefined;
  lists?: TodoListDto[] | undefined;

  constructor(data?: ITodosVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["priorityLevels"])) {
        this.priorityLevels = [] as any;
        for (let item of _data["priorityLevels"])
          this.priorityLevels!.push(PriorityLevelDto.fromJS(item));
      }
      if (Array.isArray(_data["lists"])) {
        this.lists = [] as any;
        for (let item of _data["lists"])
          this.lists!.push(TodoListDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): TodosVm {
    data = typeof data === "object" ? data : {};
    let result = new TodosVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.priorityLevels)) {
      data["priorityLevels"] = [];
      for (let item of this.priorityLevels)
        data["priorityLevels"].push(item.toJSON());
    }
    if (Array.isArray(this.lists)) {
      data["lists"] = [];
      for (let item of this.lists) data["lists"].push(item.toJSON());
    }
    return data;
  }
}

export interface ITodosVm {
  priorityLevels?: PriorityLevelDto[] | undefined;
  lists?: TodoListDto[] | undefined;
}

export class PriorityLevelDto implements IPriorityLevelDto {
  value?: number;
  name?: string | undefined;

  constructor(data?: IPriorityLevelDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.value = _data["value"];
      this.name = _data["name"];
    }
  }

  static fromJS(data: any): PriorityLevelDto {
    data = typeof data === "object" ? data : {};
    let result = new PriorityLevelDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["value"] = this.value;
    data["name"] = this.name;
    return data;
  }
}

export interface IPriorityLevelDto {
  value?: number;
  name?: string | undefined;
}

export class TodoListDto implements ITodoListDto {
  id?: number;
  title?: string | undefined;
  colour?: string | undefined;
  items?: TodoItemDto[] | undefined;

  constructor(data?: ITodoListDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.title = _data["title"];
      this.colour = _data["colour"];
      if (Array.isArray(_data["items"])) {
        this.items = [] as any;
        for (let item of _data["items"])
          this.items!.push(TodoItemDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): TodoListDto {
    data = typeof data === "object" ? data : {};
    let result = new TodoListDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["title"] = this.title;
    data["colour"] = this.colour;
    if (Array.isArray(this.items)) {
      data["items"] = [];
      for (let item of this.items) data["items"].push(item.toJSON());
    }
    return data;
  }
}

export interface ITodoListDto {
  id?: number;
  title?: string | undefined;
  colour?: string | undefined;
  items?: TodoItemDto[] | undefined;
}

export class CreateTodoListCommand implements ICreateTodoListCommand {
  room?: string | undefined;
  title?: string | undefined;

  constructor(data?: ICreateTodoListCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.room = _data["room"];
      this.title = _data["title"];
    }
  }

  static fromJS(data: any): CreateTodoListCommand {
    data = typeof data === "object" ? data : {};
    let result = new CreateTodoListCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["room"] = this.room;
    data["title"] = this.title;
    return data;
  }
}

export interface ICreateTodoListCommand {
  room?: string | undefined;
  title?: string | undefined;
}

export class UpdateTodoListCommand implements IUpdateTodoListCommand {
  id?: number;
  title?: string | undefined;

  constructor(data?: IUpdateTodoListCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.title = _data["title"];
    }
  }

  static fromJS(data: any): UpdateTodoListCommand {
    data = typeof data === "object" ? data : {};
    let result = new UpdateTodoListCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["title"] = this.title;
    return data;
  }
}

export interface IUpdateTodoListCommand {
  id?: number;
  title?: string | undefined;
}

export class SimpleUser implements ISimpleUser {
  userId?: string | undefined;
  userEmail?: string | undefined;
  username?: string | undefined;

  constructor(data?: ISimpleUser) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.userId = _data["userId"];
      this.userEmail = _data["userEmail"];
      this.username = _data["username"];
    }
  }

  static fromJS(data: any): SimpleUser {
    data = typeof data === "object" ? data : {};
    let result = new SimpleUser();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["userId"] = this.userId;
    data["userEmail"] = this.userEmail;
    data["username"] = this.username;
    return data;
  }
}

export interface ISimpleUser {
  userId?: string | undefined;
  userEmail?: string | undefined;
  username?: string | undefined;
}

export class PaginatedListOfSimpleUser implements IPaginatedListOfSimpleUser {
  items?: SimpleUser[] | undefined;
  pageIndex?: number;
  totalPages?: number;
  totalCount?: number;
  hasPreviousPage?: boolean;
  hasNextPage?: boolean;

  constructor(data?: IPaginatedListOfSimpleUser) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["items"])) {
        this.items = [] as any;
        for (let item of _data["items"])
          this.items!.push(SimpleUser.fromJS(item));
      }
      this.pageIndex = _data["pageIndex"];
      this.totalPages = _data["totalPages"];
      this.totalCount = _data["totalCount"];
      this.hasPreviousPage = _data["hasPreviousPage"];
      this.hasNextPage = _data["hasNextPage"];
    }
  }

  static fromJS(data: any): PaginatedListOfSimpleUser {
    data = typeof data === "object" ? data : {};
    let result = new PaginatedListOfSimpleUser();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.items)) {
      data["items"] = [];
      for (let item of this.items) data["items"].push(item.toJSON());
    }
    data["pageIndex"] = this.pageIndex;
    data["totalPages"] = this.totalPages;
    data["totalCount"] = this.totalCount;
    data["hasPreviousPage"] = this.hasPreviousPage;
    data["hasNextPage"] = this.hasNextPage;
    return data;
  }
}

export interface IPaginatedListOfSimpleUser {
  items?: SimpleUser[] | undefined;
  pageIndex?: number;
  totalPages?: number;
  totalCount?: number;
  hasPreviousPage?: boolean;
  hasNextPage?: boolean;
}

export class GetAllUsersWithPage implements IGetAllUsersWithPage {
  pageNumber?: number;
  pageSize?: number;

  constructor(data?: IGetAllUsersWithPage) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.pageNumber = _data["pageNumber"];
      this.pageSize = _data["pageSize"];
    }
  }

  static fromJS(data: any): GetAllUsersWithPage {
    data = typeof data === "object" ? data : {};
    let result = new GetAllUsersWithPage();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["pageNumber"] = this.pageNumber;
    data["pageSize"] = this.pageSize;
    return data;
  }
}

export interface IGetAllUsersWithPage {
  pageNumber?: number;
  pageSize?: number;
}

export class CreateUserSimpleCommand implements ICreateUserSimpleCommand {
  username?: string | undefined;
  password?: string | undefined;
  externalUserId?: string | undefined;
  groupIds?: number[] | undefined;

  constructor(data?: ICreateUserSimpleCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.username = _data["username"];
      this.password = _data["password"];
      this.externalUserId = _data["externalUserId"];
      if (Array.isArray(_data["groupIds"])) {
        this.groupIds = [] as any;
        for (let item of _data["groupIds"]) this.groupIds!.push(item);
      }
    }
  }

  static fromJS(data: any): CreateUserSimpleCommand {
    data = typeof data === "object" ? data : {};
    let result = new CreateUserSimpleCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["username"] = this.username;
    data["password"] = this.password;
    data["externalUserId"] = this.externalUserId;
    if (Array.isArray(this.groupIds)) {
      data["groupIds"] = [];
      for (let item of this.groupIds) data["groupIds"].push(item);
    }
    return data;
  }
}

export interface ICreateUserSimpleCommand {
  username?: string | undefined;
  password?: string | undefined;
  externalUserId?: string | undefined;
  groupIds?: number[] | undefined;
}

export class UserGroup extends AuditableEntity implements IUserGroup {
  id?: number;
  isChecked?: boolean;
  name?: string | undefined;
  userGroupApplicationUsers?: UserGroupApplicationUser[] | undefined;
  userRoles?: UserRole[] | undefined;

  constructor(data?: IUserGroup) {
    super(data);
  }

  init(_data?: any) {
    super.init(_data);
    if (_data) {
      this.id = _data["id"];
      this.name = _data["name"];
      if (Array.isArray(_data["userGroupApplicationUsers"])) {
        this.userGroupApplicationUsers = [] as any;
        for (let item of _data["userGroupApplicationUsers"])
          this.userGroupApplicationUsers!.push(
            UserGroupApplicationUser.fromJS(item)
          );
      }
      if (Array.isArray(_data["userRoles"])) {
        this.userRoles = [] as any;
        for (let item of _data["userRoles"])
          this.userRoles!.push(UserRole.fromJS(item));
      }
    }
  }

  static fromJS(data: any): UserGroup {
    data = typeof data === "object" ? data : {};
    let result = new UserGroup();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["name"] = this.name;
    if (Array.isArray(this.userGroupApplicationUsers)) {
      data["userGroupApplicationUsers"] = [];
      for (let item of this.userGroupApplicationUsers)
        data["userGroupApplicationUsers"].push(item.toJSON());
    }
    if (Array.isArray(this.userRoles)) {
      data["userRoles"] = [];
      for (let item of this.userRoles) data["userRoles"].push(item.toJSON());
    }
    super.toJSON(data);
    return data;
  }
}

export interface IUserGroup extends IAuditableEntity {
  id?: number;
  name?: string | undefined;
  userGroupApplicationUsers?: UserGroupApplicationUser[] | undefined;
  userRoles?: UserRole[] | undefined;
}

export class UserGroupApplicationUser implements IUserGroupApplicationUser {
  applicationUserId?: string | undefined;
  userGroup?: UserGroup | undefined;
  userGroupId?: number;

  constructor(data?: IUserGroupApplicationUser) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.applicationUserId = _data["applicationUserId"];
      this.userGroup = _data["userGroup"]
        ? UserGroup.fromJS(_data["userGroup"])
        : <any>undefined;
      this.userGroupId = _data["userGroupId"];
    }
  }

  static fromJS(data: any): UserGroupApplicationUser {
    data = typeof data === "object" ? data : {};
    let result = new UserGroupApplicationUser();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["applicationUserId"] = this.applicationUserId;
    data["userGroup"] = this.userGroup
      ? this.userGroup.toJSON()
      : <any>undefined;
    data["userGroupId"] = this.userGroupId;
    return data;
  }
}

export interface IUserGroupApplicationUser {
  applicationUserId?: string | undefined;
  userGroup?: UserGroup | undefined;
  userGroupId?: number;
}

export class UserRole extends AuditableEntity implements IUserRole {
  id?: number;
  isChecked?: boolean;
  name?: string | undefined;
  roomSet?: RoomSet | undefined;
  roomSetId?: number;
  permissionSet?: PermissionSet | undefined;
  permissionSetId?: number;
  userGroups?: UserGroup[] | undefined;

  constructor(data?: IUserRole) {
    super(data);
  }

  init(_data?: any) {
    super.init(_data);
    if (_data) {
      this.id = _data["id"];
      this.name = _data["name"];
      this.roomSet = _data["roomSet"]
        ? RoomSet.fromJS(_data["roomSet"])
        : <any>undefined;
      this.roomSetId = _data["roomSetId"];
      this.permissionSet = _data["permissionSet"]
        ? PermissionSet.fromJS(_data["permissionSet"])
        : <any>undefined;
      this.permissionSetId = _data["permissionSetId"];
      if (Array.isArray(_data["userGroups"])) {
        this.userGroups = [] as any;
        for (let item of _data["userGroups"])
          this.userGroups!.push(UserGroup.fromJS(item));
      }
    }
  }

  static fromJS(data: any): UserRole {
    data = typeof data === "object" ? data : {};
    let result = new UserRole();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["name"] = this.name;
    data["roomSet"] = this.roomSet ? this.roomSet.toJSON() : <any>undefined;
    data["roomSetId"] = this.roomSetId;
    data["permissionSet"] = this.permissionSet
      ? this.permissionSet.toJSON()
      : <any>undefined;
    data["permissionSetId"] = this.permissionSetId;
    if (Array.isArray(this.userGroups)) {
      data["userGroups"] = [];
      for (let item of this.userGroups) data["userGroups"].push(item.toJSON());
    }
    super.toJSON(data);
    return data;
  }
}

export interface IUserRole extends IAuditableEntity {
  id?: number;
  name?: string | undefined;
  roomSet?: RoomSet | undefined;
  roomSetId?: number;
  permissionSet?: PermissionSet | undefined;
  permissionSetId?: number;
  userGroups?: UserGroup[] | undefined;
}

export class PermissionSet extends AuditableEntity implements IPermissionSet {
  id?: number;
  isChecked?: boolean;
  name?: string | undefined;
  permissions?: UserPermission[] | undefined;

  constructor(data?: IPermissionSet) {
    super(data);
  }

  init(_data?: any) {
    super.init(_data);
    if (_data) {
      this.id = _data["id"];
      this.name = _data["name"];
      if (Array.isArray(_data["permissions"])) {
        this.permissions = [] as any;
        for (let item of _data["permissions"]) this.permissions!.push(item);
      }
    }
  }

  static fromJS(data: any): PermissionSet {
    data = typeof data === "object" ? data : {};
    let result = new PermissionSet();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["name"] = this.name;
    if (Array.isArray(this.permissions)) {
      data["permissions"] = [];
      for (let item of this.permissions) data["permissions"].push(item);
    }
    super.toJSON(data);
    return data;
  }
}

export interface IPermissionSet extends IAuditableEntity {
  id?: number;
  name?: string | undefined;
  permissions?: UserPermission[] | undefined;
}

export enum UserPermission {
  AllPermission = 1,
  BookingViewOnly = 2,
  BookingMakeForMyself = 3,
  BookingMakeAnyTime = 4,
  BookingMakeFixedTime = 5,
  BookingMakeAsOtherUserGroup = 6,
  BookingModifyCancel = 7,
  BookingMakeAsOtherUser = 8,
  BookingApprovalPending = 9,
  BookingModifyCancelViewRegional = 10,
  BookingModifyCancelViewAll = 11,
  BookingViewEquipment = 12,
  BookingViewAnyBooking = 13,
  BookingViewMyBooking = 14,
  BookingExtraItem = 100,
  FacilityManagement = 110,
  AccountManagement = 130,
  SmtpSetting = 190,
  ReportsAllUnit = 1000,
  ReportsOwnUnit = 2000,
}

export class CreateUserRoleCommand implements ICreateUserRoleCommand {
  name?: string | undefined;
  permissionSetId?: number;
  roomSetId?: number;

  constructor(data?: ICreateUserRoleCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data["name"];
      this.permissionSetId = _data["permissionSetId"];
      this.roomSetId = _data["roomSetId"];
    }
  }

  static fromJS(data: any): CreateUserRoleCommand {
    data = typeof data === "object" ? data : {};
    let result = new CreateUserRoleCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["name"] = this.name;
    data["permissionSetId"] = this.permissionSetId;
    data["roomSetId"] = this.roomSetId;
    return data;
  }
}

export interface ICreateUserRoleCommand {
  name?: string | undefined;
  permissionSetId?: number;
  roomSetId?: number;
}

export class UpdateUserRoleCommand implements IUpdateUserRoleCommand {
  id?: number;
  name?: string | undefined;
  permissionSetId?: number;
  roomSetId?: number;

  constructor(data?: IUpdateUserRoleCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.name = _data["name"];
      this.permissionSetId = _data["permissionSetId"];
      this.roomSetId = _data["roomSetId"];
    }
  }

  static fromJS(data: any): UpdateUserRoleCommand {
    data = typeof data === "object" ? data : {};
    let result = new UpdateUserRoleCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["name"] = this.name;
    data["permissionSetId"] = this.permissionSetId;
    data["roomSetId"] = this.roomSetId;
    return data;
  }
}

export interface IUpdateUserRoleCommand {
  id?: number;
  name?: string | undefined;
  permissionSetId?: number;
  roomSetId?: number;
}

export class DeleteUserRoleCommand implements IDeleteUserRoleCommand {
  id?: number;

  constructor(data?: IDeleteUserRoleCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): DeleteUserRoleCommand {
    data = typeof data === "object" ? data : {};
    let result = new DeleteUserRoleCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    return data;
  }
}

export interface IDeleteUserRoleCommand {
  id?: number;
}

export class CreateUserGroupCommand implements ICreateUserGroupCommand {
  name?: string | undefined;
  userIds?: string[] | undefined;
  userRoleIds?: number[] | undefined;

  constructor(data?: ICreateUserGroupCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data["name"];
      if (Array.isArray(_data["userIds"])) {
        this.userIds = [] as any;
        for (let item of _data["userIds"]) this.userIds!.push(item);
      }
      if (Array.isArray(_data["userRoleIds"])) {
        this.userRoleIds = [] as any;
        for (let item of _data["userRoleIds"]) this.userRoleIds!.push(item);
      }
    }
  }

  static fromJS(data: any): CreateUserGroupCommand {
    data = typeof data === "object" ? data : {};
    let result = new CreateUserGroupCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["name"] = this.name;
    if (Array.isArray(this.userIds)) {
      data["userIds"] = [];
      for (let item of this.userIds) data["userIds"].push(item);
    }
    if (Array.isArray(this.userRoleIds)) {
      data["userRoleIds"] = [];
      for (let item of this.userRoleIds) data["userRoleIds"].push(item);
    }
    return data;
  }
}

export class Audit {
  Rooms: string;
  RoomExtraFields: string;
  PermissionGroups: string;
  RoomGroups: string;
  PermissionGroup: string;
  UserGroups: string;
  SMTPServerSetting: string;
  Booking: string;
  EventDateTime: string;
  LoginAccout: string;
}

export interface IAudit extends IAuditableEntity {
  rooRoomsmId?: number;
  RoomExtraFields?: string | undefined;
  PermissionGroups?: string | undefined;
  RoomGroups?: string | undefined;
  UserGroups?: string | undefined;
  SMTPServerSetting?: string | undefined;
  Booking?: string | undefined;
  EventDateTime?: string | undefined;
  LoginAccout?: number;
}

export interface ICreateUserGroupCommand {
  name?: string | undefined;
  userIds?: string[] | undefined;
  userRoleIds?: number[] | undefined;
}

export class UpdateUserGroupCommand implements IUpdateUserGroupCommand {
  id?: number;
  name?: string | undefined;
  userRoleIds?: number[] | undefined;
  userIds?: string[] | undefined;

  constructor(data?: IUpdateUserGroupCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.name = _data["name"];
      if (Array.isArray(_data["userRoleIds"])) {
        this.userRoleIds = [] as any;
        for (let item of _data["userRoleIds"]) this.userRoleIds!.push(item);
      }
      if (Array.isArray(_data["userIds"])) {
        this.userIds = [] as any;
        for (let item of _data["userIds"]) this.userIds!.push(item);
      }
    }
  }

  static fromJS(data: any): UpdateUserGroupCommand {
    data = typeof data === "object" ? data : {};
    let result = new UpdateUserGroupCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["name"] = this.name;
    if (Array.isArray(this.userRoleIds)) {
      data["userRoleIds"] = [];
      for (let item of this.userRoleIds) data["userRoleIds"].push(item);
    }
    if (Array.isArray(this.userIds)) {
      data["userIds"] = [];
      for (let item of this.userIds) data["userIds"].push(item);
    }
    return data;
  }
}

export interface IUpdateUserGroupCommand {
  id?: number;
  name?: string | undefined;
  userRoleIds?: number[] | undefined;
  userIds?: string[] | undefined;
}

export class DeleteUserGroupCommand implements IDeleteUserGroupCommand {
  id?: number;

  constructor(data?: IDeleteUserGroupCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): DeleteUserGroupCommand {
    data = typeof data === "object" ? data : {};
    let result = new DeleteUserGroupCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    return data;
  }
}

export interface IDeleteUserGroupCommand {
  id?: number;
}

export class GetUserGroupById implements IGetUserGroupById {
  id?: number;

  constructor(data?: IGetUserGroupById) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): GetUserGroupById {
    data = typeof data === "object" ? data : {};
    let result = new GetUserGroupById();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    return data;
  }
}

export interface IGetUserGroupById {
  id?: number;
}

export class UserGroupDto extends AuditableEntity implements IUserGroupDto {
  id?: number;
  name?: string | undefined;
  userIds?: string[] | undefined;
  userRoleIds?: number[] | undefined;

  constructor(data?: IUserGroupDto) {
    super(data);
  }

  init(_data?: any) {
    super.init(_data);
    if (_data) {
      this.id = _data["id"];
      this.name = _data["name"];
      if (Array.isArray(_data["userIds"])) {
        this.userIds = [] as any;
        for (let item of _data["userIds"]) this.userIds!.push(item);
      }
      if (Array.isArray(_data["userRoleIds"])) {
        this.userRoleIds = [] as any;
        for (let item of _data["userRoleIds"]) this.userRoleIds!.push(item);
      }
    }
  }

  static fromJS(data: any): UserGroupDto {
    data = typeof data === "object" ? data : {};
    let result = new UserGroupDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["name"] = this.name;
    if (Array.isArray(this.userIds)) {
      data["userIds"] = [];
      for (let item of this.userIds) data["userIds"].push(item);
    }
    if (Array.isArray(this.userRoleIds)) {
      data["userRoleIds"] = [];
      for (let item of this.userRoleIds) data["userRoleIds"].push(item);
    }
    super.toJSON(data);
    return data;
  }
}

export interface IUserGroupDto extends IAuditableEntity {
  id?: number;
  name?: string | undefined;
  userIds?: string[] | undefined;
  userRoleIds?: number[] | undefined;
}

export class AddGroupToUserCommand implements IAddGroupToUserCommand {
  userId?: string | undefined;
  groupIds?: number[] | undefined;

  constructor(data?: IAddGroupToUserCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.userId = _data["userId"];
      if (Array.isArray(_data["groupIds"])) {
        this.groupIds = [] as any;
        for (let item of _data["groupIds"]) this.groupIds!.push(item);
      }
    }
  }

  static fromJS(data: any): AddGroupToUserCommand {
    data = typeof data === "object" ? data : {};
    let result = new AddGroupToUserCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["userId"] = this.userId;
    if (Array.isArray(this.groupIds)) {
      data["groupIds"] = [];
      for (let item of this.groupIds) data["groupIds"].push(item);
    }
    return data;
  }
}

export interface IAddGroupToUserCommand {
  userId?: string | undefined;
  groupIds?: number[] | undefined;
}

export class UserGroupNameDto
  extends AuditableEntity
  implements IUserGroupNameDto
{
  id?: number;
  name?: string | undefined;

  constructor(data?: IUserGroupNameDto) {
    super(data);
  }

  init(_data?: any) {
    super.init(_data);
    if (_data) {
      this.id = _data["id"];
      this.name = _data["name"];
    }
  }

  static fromJS(data: any): UserGroupNameDto {
    data = typeof data === "object" ? data : {};
    let result = new UserGroupNameDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["name"] = this.name;
    super.toJSON(data);
    return data;
  }
}

export interface IUserGroupNameDto extends IAuditableEntity {
  id?: number;
  name?: string | undefined;
}

export class UpdateSimpleUserGroupCommand
  implements IUpdateSimpleUserGroupCommand
{
  userId?: string | undefined;
  groupIds?: number[] | undefined;

  constructor(data?: IUpdateSimpleUserGroupCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.userId = _data["userId"];
      if (Array.isArray(_data["groupIds"])) {
        this.groupIds = [] as any;
        for (let item of _data["groupIds"]) this.groupIds!.push(item);
      }
    }
  }

  static fromJS(data: any): UpdateSimpleUserGroupCommand {
    data = typeof data === "object" ? data : {};
    let result = new UpdateSimpleUserGroupCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["userId"] = this.userId;
    if (Array.isArray(this.groupIds)) {
      data["groupIds"] = [];
      for (let item of this.groupIds) data["groupIds"].push(item);
    }
    return data;
  }
}

export interface IUpdateSimpleUserGroupCommand {
  userId?: string | undefined;
  groupIds?: number[] | undefined;
}

export class UserPermissionDto implements IUserPermissionDto {
  id?: number;
  value?: string | undefined;
  name?: string | undefined;

  constructor(data?: IUserPermissionDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.value = _data["value"];
      this.name = _data["name"];
    }
  }

  static fromJS(data: any): UserPermissionDto {
    data = typeof data === "object" ? data : {};
    let result = new UserPermissionDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["value"] = this.value;
    data["name"] = this.name;
    return data;
  }
}

export interface IUserPermissionDto {
  id?: number;
  value?: string | undefined;
  name?: string | undefined;
}

export class CreatePermissionSetCommand implements ICreatePermissionSetCommand {
  name?: string | undefined;
  permissions?: number[] | undefined;
  allPermission?: boolean;

  constructor(data?: ICreatePermissionSetCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data["name"];
      if (Array.isArray(_data["permissions"])) {
        this.permissions = [] as any;
        for (let item of _data["permissions"]) this.permissions!.push(item);
      }
      this.allPermission = _data["allPermission"];
    }
  }

  static fromJS(data: any): CreatePermissionSetCommand {
    data = typeof data === "object" ? data : {};
    let result = new CreatePermissionSetCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["name"] = this.name;
    if (Array.isArray(this.permissions)) {
      data["permissions"] = [];
      for (let item of this.permissions) data["permissions"].push(item);
    }
    data["allPermission"] = this.allPermission;
    return data;
  }
}

export interface ICreatePermissionSetCommand {
  name?: string | undefined;
  permissions?: number[] | undefined;
  allPermission?: boolean;
}

export class DeletePermissionSetCommand implements IDeletePermissionSetCommand {
  id?: number;

  constructor(data?: IDeletePermissionSetCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): DeletePermissionSetCommand {
    data = typeof data === "object" ? data : {};
    let result = new DeletePermissionSetCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    return data;
  }
}

export interface IDeletePermissionSetCommand {
  id?: number;
}

export class UpdatePermissionSetCommand implements IUpdatePermissionSetCommand {
  id?: number;
  name?: string | undefined;
  allPermission?: boolean;
  permissions?: number[] | undefined;

  constructor(data?: IUpdatePermissionSetCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.name = _data["name"];
      this.allPermission = _data["allPermission"];
      if (Array.isArray(_data["permissions"])) {
        this.permissions = [] as any;
        for (let item of _data["permissions"]) this.permissions!.push(item);
      }
    }
  }

  static fromJS(data: any): UpdatePermissionSetCommand {
    data = typeof data === "object" ? data : {};
    let result = new UpdatePermissionSetCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["name"] = this.name;
    data["allPermission"] = this.allPermission;
    if (Array.isArray(this.permissions)) {
      data["permissions"] = [];
      for (let item of this.permissions) data["permissions"].push(item);
    }
    return data;
  }
}

export interface IUpdatePermissionSetCommand {
  id?: number;
  name?: string | undefined;
  allPermission?: boolean;
  permissions?: number[] | undefined;
}

export class PermissionSetDto implements IPermissionSetDto {
  id?: number;
  name?: string | undefined;

  constructor(data?: IPermissionSetDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.name = _data["name"];
    }
  }

  static fromJS(data: any): PermissionSetDto {
    data = typeof data === "object" ? data : {};
    let result = new PermissionSetDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["name"] = this.name;
    return data;
  }
}

export interface IPermissionSetDto {
  id?: number;
  name?: string | undefined;
}

export class WeatherForecast implements IWeatherForecast {
  date?: Date;
  temperatureC?: number;
  temperatureF?: number;
  summary?: string | undefined;

  constructor(data?: IWeatherForecast) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.date = _data["date"]
        ? new Date(_data["date"].toString())
        : <any>undefined;
      this.temperatureC = _data["temperatureC"];
      this.temperatureF = _data["temperatureF"];
      this.summary = _data["summary"];
    }
  }

  static fromJS(data: any): WeatherForecast {
    data = typeof data === "object" ? data : {};
    let result = new WeatherForecast();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["date"] = this.date ? this.date.toISOString() : <any>undefined;
    data["temperatureC"] = this.temperatureC;
    data["temperatureF"] = this.temperatureF;
    data["summary"] = this.summary;
    return data;
  }
}

export interface IWeatherForecast {
  date?: Date;
  temperatureC?: number;
  temperatureF?: number;
  summary?: string | undefined;
}

export class GetWeatherForecastsQuery implements IGetWeatherForecastsQuery {
  city?: string | undefined;

  constructor(data?: IGetWeatherForecastsQuery) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.city = _data["city"];
    }
  }

  static fromJS(data: any): GetWeatherForecastsQuery {
    data = typeof data === "object" ? data : {};
    let result = new GetWeatherForecastsQuery();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["city"] = this.city;
    return data;
  }
}

export interface IGetWeatherForecastsQuery {
  city?: string | undefined;
}

export interface FileResponse {
  data: Blob;
  status: number;
  fileName?: string;
  headers?: { [name: string]: any };
}

export class SwaggerException extends Error {
  message: string;
  status: number;
  response: string;
  headers: { [key: string]: any };
  result: any;

  constructor(
    message: string,
    status: number,
    response: string,
    headers: { [key: string]: any },
    result: any
  ) {
    super();

    this.message = message;
    this.status = status;
    this.response = response;
    this.headers = headers;
    this.result = result;
  }

  protected isSwaggerException = true;

  static isSwaggerException(obj: any): obj is SwaggerException {
    return obj.isSwaggerException === true;
  }
}

function throwException(
  message: string,
  status: number,
  response: string,
  headers: { [key: string]: any },
  result?: any
): Observable<any> {
  if (result !== null && result !== undefined) return _observableThrow(result);
  else
    return _observableThrow(
      new SwaggerException(message, status, response, headers, null)
    );
}

function blobToText(blob: any): Observable<string> {
  return new Observable<string>((observer: any) => {
    if (!blob) {
      observer.next("");
      observer.complete();
    } else {
      let reader = new FileReader();
      reader.onload = (event) => {
        observer.next((<any>event.target).result);
        observer.complete();
      };
      reader.readAsText(blob);
    }
  });
}
export interface Iauditlogs {
  //getFullList(): Observable<RoomNameListDto[]>;
}

@Injectable({
  providedIn: "root",
})
export class auditlogs implements Iauditlogs {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }
  createAudit(query: Audit): Observable<number> {
    let url_ = this.baseUrl + "/api/Audit/addauditlog";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(query);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        Accept: "application/json",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAudit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAudit(<any>response_);
            } catch (e) {
              return <Observable<number>>(<any>_observableThrow(e));
            }
          } else return <Observable<number>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAudit(response: HttpResponseBase): Observable<number> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<number>(<any>null);
  }
}
